# graphql/TransactionsSchema.graphql
# Transactions Schema File
enum TransactionsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    UNPROCESSABLE
}

# Defines the types of the statuses for a transaction, during its lifecycle. Although these
# statuses might not match Olive's statuses 1:1, they represent what our customers see in their
# dashboard, and how we translate incoming Olive information, and communicate it to our end
# users.
enum TransactionsStatus {
    PENDING
    PROCESSED
    CREDITED
    REJECTED
}

# Defines the type of transactions that are available, depending on incoming information received
# through the Olive webhooks. The transactions processor, will handle these transaction types and
# determine whether they are offers to be redeemed, round-ups, contributions/matching, etc.
enum TransactionType {
    OFFER_REDEEMED
    ROUNDUP
    CONTRIBUTION
}

# For now we only support USD as the currency code type for transactions
enum CurrencyCodeType {
    USD
}

# this type is mainly used to define and/or work with the Transaction object before it is stored
# in the DB, as obtained from Olive.
type Transaction @aws_cognito_user_pools {
    id: ID # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float,
    totalAmount: Float,
    pendingCashbackAmount: Float # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String,
    transactionBrandAddress: String,
    transactionBrandLogoUrl: String,
    transactionBrandURLAddress: String,
    transactionIsOnline: Boolean
}

# this type is mainly used to define and/or work with the TransactionResponse object before it is stored
# in the DB, as obtained from Olive's get transaction details call - used for transactional purposes.
type TransactionResponse @aws_cognito_user_pools @aws_api_key {
    data: Transaction
    errorType: TransactionsErrorType
    errorMessage: String
}

# this type is mainly used to define and/or work with the TransactionStatusResponse object before it is stored
# in the DB, as obtained from Olive's get transaction details call - used for reimbursement purposes.
type TransactionStatusResponse @aws_cognito_user_pools @aws_api_key {
    oliveTransactionStatus: String
    errorType: TransactionsErrorType
    errorMessage: String
}

type MemberDetailsResponse @aws_cognito_user_pools @aws_api_key {
    data: String
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}

type MoonbeamUpdatedTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    updatedAt: AWSDateTime!
}

type MoonbeamTransactionByStatus @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp!
    transactionId: ID!
    transactionStatus: TransactionsStatus!
}

type MoonbeamTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransactionsResponse @aws_cognito_user_pools {
    data: [MoonbeamTransaction]
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransactionsByStatusResponse @aws_cognito_user_pools @aws_api_key {
    data: [MoonbeamTransactionByStatus]
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamUpdatedTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamUpdatedTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

input GetTransactionInput {
    id: ID! #this represents the userID which the transactions should be retrieved for
    startDate: AWSDateTime # the start time to filter transactions for
    endDate: AWSDateTime! # the end time to filter transactions for
}

input GetTransactionByStatusInput {
    id: ID! # this represents the userID which the transactions should be retrieved for
    status: TransactionsStatus! # the transactions status to filter transactions for
}

input UpdateTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    updatedAt: AWSDateTime!
}

input CreateTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}

# graphql/Root.graphql
# Main Schema File
type Query {
    getOffers(getOffersInput: GetOffersInput!): OffersResponse! @aws_cognito_user_pools
    getFidelisPartners: FidelisPartnerResponse! @aws_cognito_user_pools
    getDevicesForUser(getDevicesForUserInput: GetDevicesForUserInput!): UserDevicesResponse! @aws_cognito_user_pools @aws_api_key
    getDevice(getDeviceInput: GetDeviceInput!): UserDeviceResponse! @aws_cognito_user_pools @aws_api_key
    getDeviceByToken(getDeviceByTokenInput: GetDeviceByTokenInput!): UserDeviceResponse! @aws_cognito_user_pools @aws_api_key
    getTransaction(getTransactionInput: GetTransactionInput!): MoonbeamTransactionsResponse! @aws_cognito_user_pools
    getReimbursementByStatus(getReimbursementByStatusInput: GetReimbursementByStatusInput!): ReimbursementByStatusResponse! @aws_cognito_user_pools @aws_api_key
    getTransactionByStatus(getTransactionByStatusInput: GetTransactionByStatusInput!): MoonbeamTransactionsByStatusResponse! @aws_cognito_user_pools @aws_api_key
    getCardLink(getCardLinkInput: GetCardLinkInput!): CardLinkResponse! @aws_cognito_user_pools
    getStorage(getStorageInput: GetStorageInput!): StorageResponse! @aws_cognito_user_pools
    getMilitaryVerificationStatus(getMilitaryVerificationInput: GetMilitaryVerificationInput!): GetMilitaryVerificationResponse! @aws_cognito_user_pools
    getEligibleLinkedUsers: EligibleLinkedUsersResponse! @aws_cognito_user_pools @aws_api_key
}

type Mutation {
    addCard(addCardInput: AddCardInput!): CardLinkResponse! @aws_cognito_user_pools
    createDevice(createDeviceInput: CreateDeviceInput!): UserDeviceResponse! @aws_cognito_user_pools @aws_api_key
    updateDevice(updateDeviceInput: UpdateDeviceInput!): UserDeviceResponse! @aws_cognito_user_pools @aws_api_key
    createNotification(createNotificationInput: CreateNotificationInput!): CreateNotificationResponse! @aws_cognito_user_pools @aws_api_key
    createReimbursementEligibility(createReimbursementEligibilityInput: CreateReimbursementEligibilityInput!): ReimbursementEligibilityResponse! @aws_cognito_user_pools @aws_api_key
    updateReimbursementEligibility(updateReimbursementEligibilityInput: UpdateReimbursementEligibilityInput!): ReimbursementEligibilityResponse! @aws_cognito_user_pools @aws_api_key
    createReimbursement(createReimbursementInput: CreateReimbursementInput!): ReimbursementResponse! @aws_cognito_user_pools @aws_api_key
    updateReimbursement(updateReimbursementInput: UpdateReimbursementInput!): ReimbursementResponse! @aws_cognito_user_pools @aws_api_key
    createTransaction(createTransactionInput: CreateTransactionInput!): MoonbeamTransactionResponse! @aws_cognito_user_pools @aws_api_key
    updateTransaction(updateTransactionInput: UpdateTransactionInput!): MoonbeamUpdatedTransactionResponse! @aws_cognito_user_pools @aws_api_key
    createCardLink(createCardLinkInput: CreateCardLinkInput!): CardLinkResponse! @aws_cognito_user_pools
    deleteCard(deleteCardInput: DeleteCardInput!): CardResponse! @aws_cognito_user_pools
    updateMilitaryVerificationStatus(updateMilitaryVerificationInput: UpdateMilitaryVerificationInput!): UpdateMilitaryVerificationResponse! @aws_cognito_user_pools
    createMilitaryVerification(createMilitaryVerificationInput: CreateMilitaryVerificationInput!): CreateMilitaryVerificationResponse! @aws_cognito_user_pools
}

type Subscription {
    updatedMilitaryVerificationStatus(id: ID!): UpdateMilitaryVerificationResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["updateMilitaryVerificationStatus"])
    createdTransaction(id: ID!): MoonbeamTransactionResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["createTransaction"])
}
# graphql/AccountLinkSchema.graphql
# Storage Schema File
enum StorageErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    RESTRICTED_ACCESS
}

# Defines the types of file access levels available, implemented in line with what
# Amplify storage does.
#
# For more information, refer to:
# https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/
#
# For now just considering the public and private access levels, not protected.
enum FileAccessLevel {
    PUBLIC
    PRIVATE
    PROTECTED
}

# Defines the type of file to retrieve, which then, in turn determines the bucket that we
# read from, and implicitly, the CloudFront distribution that we read from.
enum FileType {
    MAIN
    # TBD on more file types, depending on whether we want to have additional buckets or not
}

type File @aws_cognito_user_pools {
    url: String!
}

type StorageResponse @aws_cognito_user_pools {
    data: File
    errorType: StorageErrorType
    errorMessage: String
}

input GetStorageInput {
    id: String,
    level: FileAccessLevel!,
    type: FileType!,
    name: String!,
    expires: Boolean
}
# graphql/MilitaryVerificationSchema.graphql
# Military Verification Schema File
enum MilitaryVerificationErrorType {
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum MilitaryVerificationStatusType {
    VERIFIED
    PENDING
    REJECTED
}

enum MilitaryDutyStatus {
    ACTIVE_DUTY
    NATIONAL_GUARD
    RESERVIST
    VETERAN
}

enum MilitaryBranch {
    AIR_FORCE
    ARMY
    COAST_GUARD
    MARINE_CORPS
    NAVY
    SPACE_FORCE
}

enum MilitaryAffiliation {
    SERVICE_MEMBER
    FAMILY_SPOUSE
    FAMILY_CHILD
    FAMILY_SIBLING
    FAMILY_PARENT
}

type MilitaryVerificationInformation @aws_cognito_user_pools {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
    militaryVerificationStatus: MilitaryVerificationStatusType!
}

type MilitaryVerificationStatus @aws_cognito_user_pools {
    id: ID!
    militaryVerificationStatus: MilitaryVerificationStatusType!
}

type CreateMilitaryVerificationResponse @aws_cognito_user_pools {
    data: MilitaryVerificationInformation
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type GetMilitaryVerificationResponse @aws_cognito_user_pools {
    data: MilitaryVerificationStatus
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type UpdateMilitaryVerificationResponse @aws_cognito_user_pools {
    id: ID
    militaryVerificationStatus: MilitaryVerificationStatusType
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

input UpdateMilitaryVerificationInput {
    id: ID!
    militaryVerificationStatus: MilitaryVerificationStatusType!
    updatedAt: AWSDateTime
}

input GetMilitaryVerificationInput {
    id: ID!
}

input CreateMilitaryVerificationInput {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
}
# graphql/CardLinkingSchema.graphql
# Card Linking Schema File
enum CardLinkErrorType {
    ALREADY_EXISTENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
    INVALID_CARD_SCHEME
}

enum CardType {
    MASTERCARD
    VISA
    INVALID
}

enum CardLinkingStatus {
    LINKED
    NOT_LINKED
}

type EligibleLinkedUser @aws_cognito_user_pools @aws_api_key {
    id: ID!
    memberId: ID!
    cardId: ID!
}

type Card @aws_cognito_user_pools {
    id: ID! # this will be obtained from Olive (and it is the Olive card id)
    applicationID: ID! # this will be passed on to Olive as the enrollment ID (referenceAppId)
    token: String!
    type: CardType!
    name: String!
    last4: String!
    additionalProgramID: String # not all card will have additional program IDs enrolled to them
}

type CardLink @aws_cognito_user_pools {
    id: ID! # this will be passed on to Olive as the unique user ID (extMemberId), and represents Moonbeam's unique user ID
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cards: [Card]!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    status: CardLinkingStatus! # to keep track of whether a card is linked or not, for faster fetching purposes
}

type Member @aws_cognito_user_pools {
    id: ID!
    memberId: ID!
    isActive: Boolean
}

type CardUpdate @aws_cognito_user_pools {
    id: ID!
    cardId: ID!
    updatedAt: AWSDateTime!
}

input CardInput {
    applicationID: ID # not required since this will be generated on the back-end
    token: String!
    type: CardType!
    name: String!
    last4: String!
    additionalProgramID: String # not required since cards will mainly only be enrolled into the default program ID for Moonbeam through Olive
}

input CreateCardLinkInput {
    id: ID!
    card: CardInput!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}

input AddCardInput {
    id: ID!
    memberId: ID!
    card: CardInput!
    updatedAt: AWSDateTime
}

input GetCardLinkInput {
    id: ID!
}

input DeleteCardInput {
    id: ID!
    memberId: ID!
    cardId: ID!
    updatedAt: AWSDateTime
}

type CardResponse @aws_cognito_user_pools {
    data: CardUpdate
    errorType: CardLinkErrorType
    errorMessage: String
}

type CardLinkResponse @aws_cognito_user_pools {
    data: CardLink
    errorType: CardLinkErrorType
    errorMessage: String
}

type MemberResponse @aws_cognito_user_pools {
    data: Member
    errorType: CardLinkErrorType
    errorMessage: String
}

type RemoveCardResponse @aws_cognito_user_pools {
    data: Boolean
    errorType: CardLinkErrorType
    errorMessage: String
}

type EligibleLinkedUsersResponse @aws_cognito_user_pools @aws_api_key {
    data: [EligibleLinkedUser]
    errorType: CardLinkErrorType
    errorMessage: String
}
# graphql/TransactionsSchema.graphql
# Transactions Schema File
enum TransactionsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    UNPROCESSABLE
}

# Defines the types of the statuses for a transaction, during its lifecycle. Although these
# statuses might not match Olive's statuses 1:1, they represent what our customers see in their
# dashboard, and how we translate incoming Olive information, and communicate it to our end
# users.
enum TransactionsStatus {
    PENDING
    PROCESSED
    CREDITED
    REJECTED
}

# Defines the type of transactions that are available, depending on incoming information received
# through the Olive webhooks. The transactions processor, will handle these transaction types and
# determine whether they are offers to be redeemed, round-ups, contributions/matching, etc.
enum TransactionType {
    OFFER_REDEEMED
    ROUNDUP
    CONTRIBUTION
}

# For now we only support USD as the currency code type for transactions
enum CurrencyCodeType {
    USD
}

# this type is mainly used to define and/or work with the Transaction object before it is stored
# in the DB, as obtained from Olive.
type Transaction @aws_cognito_user_pools {
    id: ID # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float,
    totalAmount: Float,
    pendingCashbackAmount: Float # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String,
    transactionBrandAddress: String,
    transactionBrandLogoUrl: String,
    transactionBrandURLAddress: String,
    transactionIsOnline: Boolean
}

# the details obtained from the Olive transaction details call, after a transaction is stores - used for reimbursement purposes.
type TransactionStatusDetails @aws_cognito_user_pools @aws_api_key {
    totalAmount: Float!,
    rewardAmount: Float!,
    creditedCashbackAmount: Float!,
    pendingCashbackAmount: Float!,
    oliveTransactionStatus: String!
}

# this type is mainly used to define and/or work with the TransactionResponse object before it is stored
# in the DB, as obtained from Olive's get transaction details call - used for transactional purposes.
type TransactionResponse @aws_cognito_user_pools @aws_api_key {
    data: Transaction
    errorType: TransactionsErrorType
    errorMessage: String
}

# this type is mainly used to define and/or work with the TransactionStatusResponse object before it is stored
# in the DB, as obtained from Olive's get transaction details call - used for reimbursement purposes.
type TransactionStatusDetailsResponse @aws_cognito_user_pools @aws_api_key {
    data: TransactionStatusDetails
    errorType: TransactionsErrorType
    errorMessage: String
}

type MemberDetailsResponse @aws_cognito_user_pools @aws_api_key {
    data: String
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}

type MoonbeamUpdatedTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    updatedAt: AWSDateTime!
}

type MoonbeamTransactionByStatus @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp!
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    creditedCashbackAmount: Float!
    pendingCashbackAmount: Float!
    rewardAmount: Float!
    totalAmount: Float!
}

type MoonbeamTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransactionsResponse @aws_cognito_user_pools {
    data: [MoonbeamTransaction]
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransactionsByStatusResponse @aws_cognito_user_pools @aws_api_key {
    data: [MoonbeamTransactionByStatus]
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamUpdatedTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamUpdatedTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

input GetTransactionInput {
    id: ID! #this represents the userID which the transactions should be retrieved for
    startDate: AWSDateTime # the start time to filter transactions for
    endDate: AWSDateTime! # the end time to filter transactions for
}

input GetTransactionByStatusInput {
    id: ID! # this represents the userID which the transactions should be retrieved for
    status: TransactionsStatus! # the transactions status to filter transactions for
}

input UpdateTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    updatedAt: AWSDateTime
}

input CreateTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}
# graphql/ReimbursementsSchema.graphql
# Reimbursements Schema File
enum ReimbursementsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    UNPROCESSABLE
}

# Defines the types of the statuses for a reimbursement, during its lifecycle. Although these
# statuses might not match Olive's statuses 1:1, they represent what our customers see in their
# dashboard, and how we translate incoming Olive information, and communicate it to our end
# users.
enum ReimbursementStatus {
    PENDING
    PROCESSED
    FAILED
}

# Defines the status for a user's reimbursement eligibility.
enum ReimbursementEligibilityStatus {
    ELIGIBLE
    INELIGIBLE
}

type ReimbursementTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
}

type ReimbursementEligibility @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    eligibilityStatus: ReimbursementEligibilityStatus!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime!
}

type Reimbursement @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    reimbursementId: ID!, # Olive specific
    clientId: ID, # Olive specific
    paymentGatewayId: ID, # Olive specific
    succeeded: Boolean, # this will only be applicable is the status is PROCESSED or FAILED
    processingMessage: String # this will only be applicable is the status is PROCESSED or FAILED so we know why something failed or succeeded
    cardId: ID!,
    reimbursementStatus: ReimbursementStatus!
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    currencyCode: CurrencyCodeType!,
    transactions:  [ReimbursementTransaction]! # this array associates particular transactions to a reimbursement object, so we know what was reimbursed to customers
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
}

type ReimbursementByStatusResponse @aws_cognito_user_pools @aws_api_key {
    data: [Reimbursement]
    errorType: ReimbursementsErrorType
    errorMessage: String
}

type ReimbursementResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the reimbursement, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: Reimbursement
    errorType: ReimbursementsErrorType
    errorMessage: String
}

type ReimbursementEligibilityResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the reimbursement eligibility, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: ReimbursementEligibility
    errorType: ReimbursementsErrorType
    errorMessage: String
}

input ReimbursementTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
}

input CreateReimbursementEligibilityInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    eligibilityStatus: ReimbursementEligibilityStatus!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}

input UpdateReimbursementEligibilityInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    eligibilityStatus: ReimbursementEligibilityStatus!
    updatedAt: AWSDateTime
}

input GetReimbursementByStatusInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    reimbursementStatus: ReimbursementStatus!
}

input CreateReimbursementInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    reimbursementId: ID!, # Olive specific
    clientId: ID, # Olive specific
    paymentGatewayId: ID, # Olive specific
    succeeded: Boolean, # this will only be applicable is the status is PROCESSED or FAILED
    processingMessage: String # this will only be applicable is the status is PROCESSED or FAILED so we know why something failed or succeeded
    cardId: ID!,
    reimbursementStatus: ReimbursementStatus!
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    currencyCode: CurrencyCodeType!,
    transactions:  [ReimbursementTransactionInput]! # this array associates particular transactions to a reimbursement object, so we know what was reimbursed to customers
    createdAt: AWSDateTime # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
}

input UpdateReimbursementInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    clientId: ID, # Olive specific
    paymentGatewayId: ID, # Olive specific
    succeeded: Boolean, # this will only be applicable is the status is PROCESSED or FAILED
    processingMessage: String # this will only be applicable is the status is PROCESSED or FAILED so we know why something failed or succeeded
    reimbursementStatus: ReimbursementStatus
    pendingCashbackAmount: Float # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactions: [ReimbursementTransactionInput] # this array associates particular transactions to a reimbursement object, so we know what was reimbursed to customers
    updatedAt: AWSDateTime
}
# graphql/NotificationsSchema.graphql
# Notifications Schema File
enum NotificationsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

enum NotificationType {
    NEW_USER_SIGNUP
    QUALIFYING_OFFER
    EXPIRATION_LINKED_CARD_NOTICE
    EXPIRED_LINKED_CARD
    NEW_QUALIFYING_OFFER_AVAILABLE
    ELIGIBLE_FOR_REIMBURSEMENT
    MARKETING_RELATED
}

enum NotificationChannelType {
    EMAIL
    SMS
    PUSH
}

enum NotificationStatus {
    SENT
    ACKNOWLEDGED
}

type Notification @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    notificationId: ID! # representing Courier's request ID, so we can link between our internal system and Courier's (obtained from Courier call)
    emailDestination: String # mostly applicable to email based notifications
    userFullName: String # mostly applicable to email based notifications
    type: NotificationType!
    channelType: NotificationChannelType!
    status: NotificationStatus!
    expoPushTokens: [String] # the push tokens for the user devices that we should send the notification to (applicable only to push notifications)
    pendingCashback: Float, # mostly applicable to push based notifications, representing the pending cashback for a qualifying transactional offer
    merchantName: String # mostly applicable to push based notifications, representing the name of the merchant for a qualifying transactional offer
    actionUrl: String # mostly applicable to push based notifications (to indicate what happens when a user taps on the notification)
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
}

input CreateNotificationInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    notificationId: ID # representing Courier's request ID, so we can link between our internal system and Courier's (obtained from Courier call)
    emailDestination: String # mostly applicable to email based notifications
    userFullName: String # mostly applicable to email based notifications
    type: NotificationType!
    channelType: NotificationChannelType!
    status: NotificationStatus!
    expoPushTokens: [String] # the push tokens for the user devices that we should send the notification to (applicable only to push notifications)
    pendingCashback: Float, # mostly applicable to push based notifications, representing the pending cashback for a qualifying transactional offer
    merchantName: String # mostly applicable to push based notifications, representing the name of the merchant for a qualifying transactional offer
    actionUrl: String # mostly applicable to push based notifications (to indicate what happens when a user taps on the notification)
    createdAt: AWSDateTime # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
}

# this input is specific for sending email notifications and will be used solely as an input object, outside of any AppSync related queries and/or mutations
input SendEmailNotificationInput {
    emailDestination: String!
    userFullName: String!
}

# this input is specific for sending mobile push notifications and will be used solely as an input object, outside of any AppSync related queries and/or mutations
input SendMobilePushNotificationInput {
    expoPushTokens: [String]!
    pendingCashback: Float!
    merchantName: String!
}

# this type is a specific response for sending notifications and will be used solely as an input object, outside of any AppSync related queries and/or mutations
type NotificationResponse @aws_cognito_user_pools @aws_api_key {
    requestId: ID # Courier specific request ID
    errorType: NotificationsErrorType
    errorMessage: String
}

type CreateNotificationResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the notification, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: Notification
    errorType: NotificationsErrorType
    errorMessage: String
}
# graphql/PhysicalDevicesSchema.graphql
# Physical Devices Schema File
enum UserDeviceErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

# signals whether a user is actively using a device or not (if they are signed out, device deleted/replaced etc.)
enum UserDeviceState {
    ACTIVE
    INACTIVE
}

type PushDevice @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the devices belongs to
    tokenId: ID! # this represents the Expo push token ID for a particular physical device
    deviceState: UserDeviceState!
    lastLoginDate: AWSDateTime!
}

type UserDeviceResponse @aws_cognito_user_pools @aws_api_key {
    data: PushDevice
    errorType: UserDeviceErrorType
    errorMessage: String
}

type UserDevicesResponse @aws_cognito_user_pools @aws_api_key {
    data: [PushDevice]
    errorType: UserDeviceErrorType
    errorMessage: String
}

input GetDevicesForUserInput {
    id: ID!
}

input GetDeviceInput {
    id: ID!,
    tokenId: ID!
}

input GetDeviceByTokenInput {
    tokenId: ID!
}

input CreateDeviceInput {
    id: ID! # this represents the userID which the devices belongs to
    tokenId: ID! # this represents the Expo push token ID for a particular physical device
    deviceState: UserDeviceState!
    lastLoginDate: AWSDateTime
}

input UpdateDeviceInput {
    id: ID! # this represents the userID which the devices belongs to
    tokenId: ID! # this represents the Expo push token ID for a particular physical device
    deviceState: UserDeviceState!
    lastLoginDate: AWSDateTime
}
# graphql/OffersSchema.graphql
# Offers Schema File
enum OffersErrorType {
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

enum OfferState {
    pending
    scheduled
    active
    expired
    paused
    archived
}

enum OfferAvailability {
    client_only
    global
}

enum OfferReach {
    state
    national
    online_only
}

enum RedemptionType {
    cardlinked
    click
    mobile
}

enum RedemptionTrigger {
    minimum_purchase_amount,
    purchase_frequency,
    cumulative_purchase_amount
}

enum RewardType {
    reward_amount
    reward_percent
}

enum CountryCode {
    US
    CA
}

enum OfferFilter {
    FIDELIS
    ONLINE
    NEARBY
}

# this is an Olive-based object, and therefore since their documentation lacks clarity on which fields are
# required and which fields are not, we will make them all optional
# https://developer.oliveltd.com/reference/the-offer-object
type OfferStoreGeoLocation @aws_cognito_user_pools {
    latitude: Float
    longitude: Float
}

# this is an Olive-based object, and therefore since their documentation lacks clarity on which fields are
# required and which fields are not, we will make them all optional
# https://developer.oliveltd.com/reference/the-offer-object
type OfferStore @aws_cognito_user_pools {
    id: ID
    name: String
    phone: String
    address1: String
    city: String
    state: String
    countryCode: CountryCode
    postCode: String
    geoLocation: OfferStoreGeoLocation
    isOnline: Boolean
    distance: Float
}

# this is an Olive-based object, and therefore since their documentation lacks clarity on which fields are
# required and which fields are not, we will make them all optional
# https://developer.oliveltd.com/reference/the-offer-object
type Reward @aws_cognito_user_pools {
    type: RewardType
    value: Float
    maxValue: Float
}

# this is an Olive-based object, and therefore since their documentation lacks clarity on which fields are
# required and which fields are not, we will make them all optional
# https://developer.oliveltd.com/reference/the-offer-object
type Offer @aws_cognito_user_pools {
    id:	ID
    corporateId: ID
    created: AWSDateTime
    offerState:	OfferState
    availability: OfferAvailability
    brandId: ID
    brandDba: String
    brandLogo: String
    brandLogoSm: String
    brandBanner: String
    brandParentCategory: String
    brandStubCopy: String
    storeDetails: [OfferStore]
    description: String
    reach: OfferReach
    title: String
    qualifier: String
    tile: String
    startDate: AWSDateTime
    endDate: AWSDateTime
    currency: CurrencyCodeType
    extOfferId: ID
    supplierOfferKey: ID
    redemptionType: RedemptionType
    redemptionInstructionUrl: String
    redemptionTrigger: RedemptionTrigger
    budget: Float
    daysAvailability: [Int]
    stores: [ID]
    totalRedeemLimit: Int
    redeemLimitPerUser:	Int
    purchaseAmount:	Float
    purchaseFrequency: Int
    reward: Reward
}

type OffersPaginatedResponse @aws_cognito_user_pools {
    totalNumberOfPages: Int!
    totalNumberOfRecords: Int!
    offers: [Offer]!
}

type FidelisPartner @aws_cognito_user_pools {
    brandName: String!
    numberOfOffers: Int!
    offers: [Offer]!
}

type OffersResponse @aws_cognito_user_pools {
    data: OffersPaginatedResponse
    errorType: OffersErrorType
    errorMessage: String
}

type FidelisPartnerResponse @aws_cognito_user_pools {
    data: [FidelisPartner]
    errorType: OffersErrorType
    errorMessage: String
}

input GetOffersInput {
    filterType: OfferFilter!
    availability: OfferAvailability!
    offerStates: [OfferState]!
    countryCode: CountryCode!
    redemptionType: RedemptionType!
    pageSize: Int!
    pageNumber: Int!
    brandName: String
    radiusLatitude: Float # required only when the offer filter is NEARBY
    radiusLongitude: Float # required only when the offer filter is NEARBY
    radius: Int # required only when the offer filter is NEARBY
    radiusIncludeOnlineStores: Boolean # required only when the offer filter is NEARBY
}


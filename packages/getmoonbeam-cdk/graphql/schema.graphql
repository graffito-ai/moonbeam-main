# graphql/Root.graphql
# Main Schema File
type Query {
    geoCodeAsync(geocodeAsyncInput: GeocodeAsyncInput!): GeocodeAsyncResponse! @aws_cognito_user_pools
    getFAQs: FAQResponse! @aws_cognito_user_pools
    getOffers(getOffersInput: GetOffersInput!): OffersResponse! @aws_cognito_user_pools
    searchOffers(searchOffersInput: SearchOffersInput!): OffersResponse! @aws_cognito_user_pools
    getPremierOffers(getOffersInput: GetOffersInput!): OffersResponse! @aws_cognito_user_pools
    getSeasonalOffers(getOffersInput: GetOffersInput!): OffersResponse! @aws_cognito_user_pools
    getFidelisPartners: FidelisPartnerResponse! @aws_cognito_user_pools
    getServicePartners: PartnerResponse! @aws_cognito_user_pools
    getEventSeries: EventSeriesResponse! @aws_cognito_user_pools @aws_api_key
    getDevicesForUser(getDevicesForUserInput: GetDevicesForUserInput!): UserDevicesResponse! @aws_cognito_user_pools @aws_api_key
    getTransaction(getTransactionInput: GetTransactionInput!): MoonbeamTransactionsResponse! @aws_cognito_user_pools @aws_api_key
    getTransactionsInRange(getTransactionsInRangeInput: GetTransactionsInRangeInput!): MoonbeamTransactionsResponse! @aws_cognito_user_pools @aws_api_key
    getTransactionByStatus(getTransactionByStatusInput: GetTransactionByStatusInput!): MoonbeamTransactionsByStatusResponse! @aws_cognito_user_pools @aws_api_key
    getCardLink(getCardLinkInput: GetCardLinkInput!): CardLinkResponse! @aws_cognito_user_pools
    getStorage(getStorageInput: GetStorageInput!): StorageResponse! @aws_cognito_user_pools @aws_api_key
    getFilesForUser(getFilesForUserInput: GetFilesForUserInput!): FilesForUserResponse! @aws_cognito_user_pools
    getMilitaryVerificationStatus(getMilitaryVerificationInput: GetMilitaryVerificationInput!): GetMilitaryVerificationResponse! @aws_cognito_user_pools
    getEligibleLinkedUsers: EligibleLinkedUsersResponse! @aws_cognito_user_pools @aws_api_key
    getUsersWithNoCards: IneligibleLinkedUsersResponse! @aws_cognito_user_pools @aws_api_key
    getNotificationReminders: NotificationReminderResponse! @aws_cognito_user_pools @aws_api_key
    getAllUsersForNotificationReminders: UserForNotificationReminderResponse! @aws_cognito_user_pools @aws_api_key
    getAllUsersEligibleForReimbursements: UserForNotificationReminderResponse! @aws_cognito_user_pools @aws_api_key
    getAllUsersIneligibleForReimbursements: UserForNotificationReminderResponse! @aws_cognito_user_pools @aws_api_key
    getUsersByGeographyForNotificationReminders(getUsersByGeographicalLocationInput :GetUsersByGeographicalLocationInput!): UserForNotificationReminderResponse! @aws_cognito_user_pools @aws_api_key
    getUserAuthSession(getUserAuthSessionInput: GetUserAuthSessionInput!): UserAuthSessionResponse! @aws_cognito_user_pools
    getAppUpgradeCredentials: AppUpgradeResponse! @aws_cognito_user_pools
    getReferralsByStatus(getReferralsByStatusInput: GetReferralsByStatusInput!): ReferralResponse! @aws_cognito_user_pools @aws_api_key
    getUserFromReferral(userFromReferralInput: UserFromReferralInput!): UserFromReferralResponse! @aws_cognito_user_pools @aws_api_key
    getUserCardLinkingId(getUserCardLinkingIdInput: GetUserCardLinkingIdInput!): GetUserCardLinkingIdResponse! @aws_cognito_user_pools @aws_api_key
    getMilitaryVerificationInformation(getMilitaryVerificationInformationInput: GetMilitaryVerificationInformationInput!): MilitaryVerificationReportingInformationResponse! @aws_cognito_user_pools @aws_api_key
    getAppReviewEligibility(getAppReviewEligibilityInput: GetAppReviewEligibilityInput!): GetAppReviewEligibilityResponse! @aws_cognito_user_pools
    getLocationPredictions(getLocationPredictionsInput: GetLocationPredictionsInput!): GetLocationPredictionsResponse! @aws_cognito_user_pools @aws_iam
    getReimbursements(getReimbursementsInput: GetReimbursementsInput!): ReimbursementResponse! @aws_cognito_user_pools
    getNotificationByType(getNotificationByTypeInput: GetNotificationByTypeInput!): GetNotificationByTypeResponse! @aws_cognito_user_pools @aws_api_key
    getDailyEarningsSummary(getDailyEarningsSummaryInput: GetDailyEarningsSummaryInput!): DailyEarningsSummaryResponse! @aws_cognito_user_pools @aws_api_key
    getUserNotificationAssets(getUserNotificationAssetsInput: GetUserNotificationAssetsInput!): UserNotificationAssetsResponse! @aws_cognito_user_pools @aws_api_key
}

type Mutation {
    acknowledgeLocationUpdate(createLocationBasedOfferReminderInput: CreateLocationBasedOfferReminderInput!): LocationBasedOfferReminderResponse! @aws_cognito_user_pools @aws_iam
    createEventSeries(createEventSeriesInput: CreateEventSeriesInput!): EventSeriesResponse! @aws_cognito_user_pools @aws_api_key
    createServicePartner(createPartnerInput: CreatePartnerInput!): PartnerResponse! @aws_cognito_user_pools
    updateCard(updateCardInput: UpdateCardInput!): EligibleLinkedUsersResponse! @aws_cognito_user_pools @aws_api_key
    addCard(addCardInput: AddCardInput!): CardLinkResponse! @aws_cognito_user_pools
    createFAQ(createFAQInput: CreateFAQInput!): FAQResponse! @aws_cognito_user_pools
    createDevice(createDeviceInput: CreateDeviceInput!): UserDeviceResponse! @aws_cognito_user_pools @aws_api_key
    createNotification(createNotificationInput: CreateNotificationInput!): CreateNotificationResponse! @aws_cognito_user_pools @aws_api_key
    createTransaction(createTransactionInput: CreateTransactionInput!): MoonbeamTransactionResponse! @aws_cognito_user_pools @aws_api_key
    updateTransaction(updateTransactionInput: UpdateTransactionInput!): MoonbeamUpdatedTransactionResponse! @aws_cognito_user_pools @aws_api_key
    createCardLink(createCardLinkInput: CreateCardLinkInput!): CardLinkResponse! @aws_cognito_user_pools
    deleteCard(deleteCardInput: DeleteCardInput!): CardResponse! @aws_cognito_user_pools
    updateMilitaryVerificationStatus(updateMilitaryVerificationInput: UpdateMilitaryVerificationInput!): UpdateMilitaryVerificationResponse! @aws_cognito_user_pools
    createMilitaryVerification(createMilitaryVerificationInput: CreateMilitaryVerificationInput!): CreateMilitaryVerificationResponse! @aws_cognito_user_pools
    createUserAuthSession(createUserAuthSessionInput: CreateUserAuthSessionInput!): UserAuthSessionResponse! @aws_cognito_user_pools
    updateUserAuthSession(updateUserAuthSessionInput: UpdateUserAuthSessionInput!): UserAuthSessionResponse! @aws_cognito_user_pools
    createNotificationReminder(createNotificationReminderInput: CreateNotificationReminderInput!): NotificationReminderResponse! @aws_cognito_user_pools
    updateNotificationReminder(updateNotificationReminderInput: UpdateNotificationReminderInput!): NotificationReminderResponse! @aws_cognito_user_pools @aws_api_key
    createReferral(createReferralInput: CreateReferralInput!): ReferralResponse! @aws_cognito_user_pools @aws_api_key
    updateReferral(updateReferralInput: UpdateReferralInput!): ReferralResponse! @aws_cognito_user_pools @aws_api_key
    createLogEvent(createLogEventInput: CreateLogEventInput!): LoggingResponse! @aws_cognito_user_pools @aws_iam
    putMilitaryVerificationReport(putMilitaryVerificationReportInput: PutMilitaryVerificationReportInput!): MilitaryVerificationReportResponse! @aws_cognito_user_pools @aws_api_key
    createAppReview(createAppReviewInput: CreateAppReviewInput!): AppReviewResponse! @aws_cognito_user_pools
    createReimbursement(createReimbursementInput: CreateReimbursementInput!): ReimbursementResponse! @aws_cognito_user_pools
    createDailyEarningsSummary(createDailyEarningsSummaryInput: CreateDailyEarningsSummaryInput!): DailyEarningsSummaryResponse! @aws_cognito_user_pools @aws_api_key
    updateDailyEarningsSummary(updateDailyEarningsSummaryInput: UpdateDailyEarningsSummaryInput!): DailyEarningsSummaryResponse! @aws_cognito_user_pools @aws_api_key
}

type Subscription {
    updatedMilitaryVerificationStatus(id: ID!): UpdateMilitaryVerificationResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["updateMilitaryVerificationStatus"])
    createdTransaction(id: ID!): MoonbeamTransactionResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["createTransaction"])
    updatedTransaction(id: ID!): MoonbeamUpdatedTransactionResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["updateTransaction"])
}
# graphql/AccountLinkSchema.graphql
# Storage Schema File
enum StorageErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    RESTRICTED_ACCESS
}

# Defines the types of file access levels available, implemented in line with what
# Amplify storage does.
#
# For more information, refer to:
# https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/
#
# For now just considering the public and private access levels, not protected.
enum FileAccessLevel {
    PUBLIC
    PRIVATE
    PROTECTED
}

# Defines the type of file to retrieve, which then, in turn determines the bucket that we
# read from, and implicitly, the CloudFront distribution that we read from.
enum FileType {
    MAIN
    LOGOFILES
}

type File @aws_cognito_user_pools @aws_api_key {
    url: String!
}

type StorageResponse @aws_cognito_user_pools @aws_api_key {
    data: File
    errorType: StorageErrorType
    errorMessage: String
}

type MilitaryVerificationReportResponse @aws_api_key @aws_cognito_user_pools {
    data: String # representing the S3 location of the file to append to
    errorType: StorageErrorType
    errorMessage: String
}

type FilesForUserResponse @aws_cognito_user_pools {
    data: [String]
    errorType: StorageErrorType
    errorMessage: String
}

input GetFilesForUserInput {
    id: ID!, # representing the Moonbeam user id
    level: FileAccessLevel!,
    type: FileType!
}

input GetStorageInput {
    id: String,
    level: FileAccessLevel!,
    type: FileType!,
    name: String!,
    expires: Boolean
}

input PutMilitaryVerificationReportInput {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
    militaryVerificationStatus: MilitaryVerificationStatusType!
    phoneNumber: String!
    emailAddress: String!
    date: AWSDate!
    reportNumber: AWSTimestamp!
}
# graphql/MilitaryVerificationSchema.graphql
# Military Verification Schema File
enum MilitaryVerificationErrorType {
    UNPROCESSABLE
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum MilitaryVerificationStatusType {
    VERIFIED
    PENDING
    REJECTED
}

enum MilitaryDutyStatus {
    ACTIVE_DUTY
    NATIONAL_GUARD
    RESERVIST
    VETERAN
    NOT_APPLICABLE
}

enum MilitaryBranch {
    AIR_FORCE
    ARMY
    COAST_GUARD
    MARINE_CORPS
    NAVY
    SPACE_FORCE
    NOT_APPLICABLE
}

enum MilitaryAffiliation {
    SERVICE_MEMBER
    FAMILY_SPOUSE
    FAMILY_CHILD
    FAMILY_SIBLING
    FAMILY_PARENT
}

type MilitaryVerificationInformation @aws_cognito_user_pools {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
    militaryVerificationStatus: MilitaryVerificationStatusType!
}

type MilitaryVerificationStatus @aws_cognito_user_pools {
    id: ID!
    militaryVerificationStatus: MilitaryVerificationStatusType!
}

type CreateMilitaryVerificationResponse @aws_cognito_user_pools {
    data: MilitaryVerificationInformation
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type GetMilitaryVerificationResponse @aws_cognito_user_pools {
    data: MilitaryVerificationStatus
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type UpdateMilitaryVerificationResponse @aws_cognito_user_pools {
    id: ID
    militaryVerificationStatus: MilitaryVerificationStatusType
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type MilitaryVerificationNotificationUpdate @aws_cognito_user_pools @aws_api_key {
    id: ID!
    originalMilitaryVerificationStatus: MilitaryVerificationStatusType!
    newMilitaryVerificationStatus: MilitaryVerificationStatusType!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
}

input UpdateMilitaryVerificationInput {
    id: ID!
    militaryVerificationStatus: MilitaryVerificationStatusType!
    updatedAt: AWSDateTime
}

input GetMilitaryVerificationInput {
    id: ID!
}

input CreateMilitaryVerificationInput {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
    personalIdentifier: String # this is going to be applicable only for family members
}

input GetMilitaryVerificationInformationInput {
    id: ID # representing the Moonbeam custom user id
    startDate: AWSDateTime # representing the start date bound
    endDate: AWSDateTime # representing the end date bound
}
# graphql/CardLinkingSchema.graphql
# Card Linking Schema File
enum CardLinkErrorType {
    ALREADY_EXISTENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
    INVALID_CARD_SCHEME
}

enum CardType {
    MASTERCARD
    VISA
    INVALID
}

enum CardLinkingStatus {
    LINKED
    NOT_LINKED
}

type EligibleLinkedUser @aws_cognito_user_pools @aws_api_key {
    id: ID!
    memberId: ID!
    cardIds: [ID]!
}

type Card @aws_cognito_user_pools {
    id: ID! # this will be obtained from Olive (and it is the Olive card id)
    applicationID: ID! # this will be passed on to Olive as the enrollment ID (referenceAppId)
    token: String!
    type: CardType!
    name: String!
    last4: String!
    expiration: String
    additionalProgramID: String # not all card will have additional program IDs enrolled to them
}

type CardLink @aws_cognito_user_pools {
    id: ID! # this will be passed on to Olive as the unique user ID (extMemberId), and represents Moonbeam's unique user ID
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cards: [Card]!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    status: CardLinkingStatus! # to keep track of whether a card is linked or not, for faster fetching purposes
}

type Member @aws_cognito_user_pools {
    id: ID!
    memberId: ID!
    isActive: Boolean
}

type CardUpdate @aws_cognito_user_pools {
    id: ID!
    cardId: ID!
    updatedAt: AWSDateTime!
}

input CardInput {
    applicationID: ID # not required since this will be generated on the back-end
    token: String!
    type: CardType!
    name: String!
    last4: String!
    expiration: String!
    additionalProgramID: String # not required since cards will mainly only be enrolled into the default program ID for Moonbeam through Olive
}

input CreateCardLinkInput {
    id: ID!
    card: CardInput!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}

input AddCardInput {
    id: ID!
    memberId: ID!
    card: CardInput!
    updatedAt: AWSDateTime
}

input GetCardLinkInput {
    id: ID!
}

input UpdateCardInput {
    id: ID!
    memberId: ID!
    cardId: ID!
    expirationDate: String!
    updatedAt: AWSDateTime
}

input DeleteCardInput {
    id: ID!
    memberId: ID!
    cardId: ID!
    updatedAt: AWSDateTime
}

input GetUserCardLinkingIdInput {
    id: ID! # this will be passed on to Olive as the unique user ID (extMemberId), and represents Moonbeam's unique user ID
}

type GetUserCardLinkingIdResponse @aws_cognito_user_pools @aws_api_key {
    data: ID # this represents the Olive (or other card linking provider's) member id
    errorType: CardLinkErrorType
    errorMessage: String
}

type CardDetailsResponse @aws_cognito_user_pools @aws_api_key {
    data: String
    errorType: CardLinkErrorType
    errorMessage: String
}

type CardResponse @aws_cognito_user_pools {
    data: CardUpdate
    errorType: CardLinkErrorType
    errorMessage: String
}

type CardLinkResponse @aws_cognito_user_pools {
    data: CardLink
    errorType: CardLinkErrorType
    errorMessage: String
}

type MemberResponse @aws_cognito_user_pools {
    data: Member
    errorType: CardLinkErrorType
    errorMessage: String
}

type RemoveCardResponse @aws_cognito_user_pools {
    data: Boolean
    errorType: CardLinkErrorType
    errorMessage: String
}

type EligibleLinkedUsersResponse @aws_cognito_user_pools @aws_api_key {
    data: [EligibleLinkedUser]
    errorType: CardLinkErrorType
    errorMessage: String
}

type RetrieveUserDetailsForNotifications @aws_cognito_user_pools @aws_api_key {
    id: ID!
    email: String!
    firstName: String!
    lastName: String!
}

type IneligibleLinkedUsersResponse @aws_cognito_user_pools @aws_api_key {
    data: [RetrieveUserDetailsForNotifications]
    errorType: CardLinkErrorType
    errorMessage: String
}
## graphql/TransactionsSchema.graphql
## Transactions Schema File
enum TransactionsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    UNPROCESSABLE
}

## Defines the types of the statuses for a transaction, during its lifecycle. Although these
## statuses might not match Olive's statuses 1:1, they represent what our customers see in their
## dashboard, and how we translate incoming Olive information, and communicate it to our end
## users.
enum TransactionsStatus {
    PENDING ## pending  = transaction is a qualifying offer, and it is pending merchant approval and funding
    PROCESSED ## processed = transaction is a qualifying offer, and it has been approved and funded by the merchant
    FUNDED ## funded = transaction is a qualifying offer, and it has been approved and funded by the merchant, and its cashback credited back to Moonbeam
    FRONTED ## fronted - transaction is a qualifying offer, and it has been approved and funded by the merchant, and its cashback has not been credited back to Moonbeam, but it has been credited back to the user
    CREDITED ## credited = transaction is a qualifying offer, and it has been approved and funded by the merchant, its cashback credited back to Moonbeam and also credited back to the user
    REJECTED ## rejected = transaction is a qualifying offer, and it has been rejected for some particular reason
}

## Defines the type of transactions that are available, depending on incoming information received
## through the Olive webhooks. The transactions processor, will handle these transaction types and
## determine whether they are offers to be redeemed, round-ups, contributions/matching, etc.
enum TransactionType {
    OFFER_REDEEMED
    ROUNDUP
    CONTRIBUTION
    OLIVE_INELIGIBLE_UNMATCHED ## oliveIneligibleUnmatched = transaction coming from the Olive platform that did not match to an offer.
    OLIVE_INELIGIBLE_MATCHED ### oliveIneligibleMatched = transaction coming from the Olive platform that did match to an offer, but for some reason it did not qualify and has brand/store details associated (think click offers).
}

## For now we only support USD as the currency code type for transactions
enum CurrencyCodeType {
    USD
}

## this type is mainly used to define and/or work with the ineligible Transaction object before it is stored
## in the DB, as obtained from Olive.
type IneligibleTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID ## this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! ## this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
    memberId: ID! ## this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID
    storeId: ID
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float,
    totalAmount: Float,
    pendingCashbackAmount: Float ## this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float ## this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String,
    transactionBrandAddress: String,
    transactionBrandLogoUrl: String,
    transactionBrandURLAddress: String,
    transactionIsOnline: Boolean
}

## this type is mainly used to define and/or work with the Transaction object before it is stored
## in the DB, as obtained from Olive.
type Transaction @aws_cognito_user_pools @aws_api_key {
    id: ID ## this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! ## this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
    memberId: ID! ## this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float,
    totalAmount: Float,
    pendingCashbackAmount: Float ## this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float ## this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String,
    transactionBrandAddress: String,
    transactionBrandLogoUrl: String,
    transactionBrandURLAddress: String,
    transactionIsOnline: Boolean
}

## this type is mainly used to define and/or work with the UpdateTransactionEvent object for the updated transaction webhook
type UpdateTransactionEventTransactionData @aws_cognito_user_pools @aws_api_key {
    id: ID!
    rewardAmount: Float!
    cardId: ID!
    amount: Float
    currencyCode: CurrencyCodeType!
    created: AWSDateTime
    storeId: ID
    brandId: ID
    roundedAmount: Float
    matchingAmount: Float
    roundingRuleId: String
    loyaltyProgramId: String
    merchantCategoryCode: String
    moonbeamTransactionStatus: TransactionsStatus
}

## this type is mainly used to define and/or work with the UpdateTransactionEvent object for the updated transaction webhook
type UpdatedTransactionEventData @aws_cognito_user_pools @aws_api_key {
    webhookEventType: String!
    cardId: ID!
    memberId: ID!
    redeemedMatchings: [String]!
    transaction: UpdateTransactionEventTransactionData!
}

## this type is mainly used to define and/or work with the UpdateTransactionEvent object for the updated transaction webhook
type UpdatedTransactionEvent @aws_cognito_user_pools @aws_api_key {
    id: ID!
    subscriptionId: ID!
    timestamp: AWSTimestamp!
    callbackUrl: String!
    topic: String!
    data: UpdatedTransactionEventData!
}

## this type is mainly used to define and/or work with the UpdateTransactionEvent object for the updated transaction webhook
type UpdatedTransactionEventResponse @aws_cognito_user_pools @aws_api_key {
    data: UpdatedTransactionEvent
    errorType: TransactionsErrorType
    errorMessage: String
}

## the details obtained from the Olive transaction details call, after a transaction is stores - used for reimbursement purposes.
type TransactionStatusDetails @aws_cognito_user_pools @aws_api_key {
    totalAmount: Float!,
    rewardAmount: Float!,
    creditedCashbackAmount: Float!,
    pendingCashbackAmount: Float!,
    oliveTransactionStatus: String!
}

## this type is mainly used to define and/or work with the TransactionResponse object before it is stored
## in the DB, as obtained from Olive's get transaction details call - used for transactional purposes.
type TransactionResponse @aws_cognito_user_pools @aws_api_key {
    data: Transaction
    errorType: TransactionsErrorType
    errorMessage: String
}

## this type is mainly used to define and/or work with the IneligibleTransactionResponse object before it is stored
## in the DB, as obtained from Olive's get transaction details call - used for ineligible transactional purposes.
type IneligibleTransactionResponse @aws_cognito_user_pools @aws_api_key {
    data: IneligibleTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

## this type is mainly used to define and/or work with the TransactionStatusResponse object before it is stored
## in the DB, as obtained from Olive's get transaction details call - used for reimbursement purposes.
type TransactionStatusDetailsResponse @aws_cognito_user_pools @aws_api_key {
    data: TransactionStatusDetails
    errorType: TransactionsErrorType
    errorMessage: String
}

type MemberDetailsResponse @aws_cognito_user_pools @aws_api_key {
    data: String
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! ## this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! ## this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! ## this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! ## this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! ## this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}

type MoonbeamUpdatedTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! ## this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    updatedAt: AWSDateTime!
}

type MoonbeamTransactionByStatus @aws_cognito_user_pools @aws_api_key {
    id: ID! ## this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp!
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    creditedCashbackAmount: Float!
    pendingCashbackAmount: Float!
    rewardAmount: Float!
    totalAmount: Float!
}

type MoonbeamTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID ## this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransactionsResponse @aws_cognito_user_pools @aws_api_key {
    data: [MoonbeamTransaction]
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransactionsByStatusResponse @aws_cognito_user_pools @aws_api_key {
    data: [MoonbeamTransactionByStatus]
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamUpdatedTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID ## this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamUpdatedTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

type OfferIdResponse @aws_cognito_user_pools @aws_api_key {
    data: ID # this represents the ID of the offer id that was redeemed through the transaction
    errorType: TransactionsErrorType
    errorMessage: String
}

type OfferRedemptionTypeResponse @aws_cognito_user_pools @aws_api_key {
    data: RedemptionType # this represents the redemption type for the offer
    errorType: TransactionsErrorType
    errorMessage: String
}

input GetTransactionInput {
    id: ID! ## this represents the userID which the transactions should be retrieved for
    startDate: AWSDateTime ## the start time to filter transactions for
    endDate: AWSDateTime! ## the end time to filter transactions for
}

input GetTransactionsInRangeInput {
    startDate: AWSDateTime! ## the start time to filter transactions for
    endDate: AWSDateTime! ## the end time to filter transactions for
}

input GetTransactionByStatusInput {
    id: ID! ## this represents the userID which the transactions should be retrieved for
    status: TransactionsStatus! ## the transactions status to filter transactions for
}

input UpdateTransactionInput {
    id: ID! ## this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    updatedAt: AWSDateTime
}

input CreateTransactionInput {
    id: ID! ## this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! ## this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! ## this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! ## this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! ## this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}

input MoonbeamTransactionInput {
    id: ID! ## this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! ## this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! ## this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! ## this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! ## this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}
# graphql/NotificationsSchema.graphql
# Notifications Schema File
enum NotificationsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

enum NotificationType {
    CARD_LINKING_REMINDER
    NEW_MAP_FEATURE_REMINDER
    VETERANS_DAY_TEMPLATE_1_REMINDER
    VETERANS_DAY_TEMPLATE_2_REMINDER
    VETERANS_DAY_TEMPLATE_3_REMINDER
    NEW_USER_SIGNUP
    QUALIFYING_OFFER
    INELIGIBLE_TRANSACTION
    MILITARY_STATUS_CHANGED_PENDING_TO_VERIFIED
    MILITARY_STATUS_CHANGED_PENDING_TO_REJECTED
    EXPIRATION_LINKED_CARD_NOTICE
    EXPIRED_LINKED_CARD
    NEW_QUALIFYING_OFFER_AVAILABLE
    ELIGIBLE_FOR_REIMBURSEMENT
    MARKETING_RELATED
    REFERRAL_TEMPLATE_LAUNCH
    REFERRAL_TEMPLATE_1_REMINDER
    REFERRAL_TEMPLATE_2_REMINDER
    REFERRAL_TEMPLATE_3_REMINDER
    MULTIPLE_CARD_FEATURE_REMINDER
    SPOUSE_FEATURE_REMINDER
    FEEDBACK_TEMPLATE_1_REMINDER
    LOCATION_BASED_OFFER_REMINDER
    SAN_ANTONIO_REFERRAL_TEMPLATE_1_REMINDER
    REIMBURSEMENTS_REMINDER
    SPENDING_TEMPLATE_1_REMINDER
    DAILY_EARNINGS_SUMMARY
}

enum NotificationChannelType {
    EMAIL
    SMS
    PUSH
}

enum NotificationStatus {
    SENT
    ACKNOWLEDGED
}

type Notification @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    notificationId: ID! # representing Courier's request ID, so we can link between our internal system and Courier's (obtained from Courier call)
    emailDestination: String # mostly applicable to email based notifications
    userFullName: String # mostly applicable to email based notifications
    type: NotificationType!
    channelType: NotificationChannelType!
    status: NotificationStatus!
    expoPushTokens: [String] # the push tokens for the user devices that we should send the notification to (applicable only to push notifications)
    pendingCashback: Float, # mostly applicable to push based notifications, representing the pending cashback for a qualifying transactional offer
    merchantName: String # mostly applicable to push based notifications, representing the name of the merchant for a qualifying transactional offer
    actionUrl: String # mostly applicable to push based notifications (to indicate what happens when a user taps on the notification)
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
}

type UserNotificationsAssets @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID of the user used to retrieve notification assets for
    email: String! # email address of the user
    pushToken: String!
}

input CreateNotificationInput {
    id: ID! # this represents the userID which the notification belongs to/was sent to
    timestamp: AWSTimestamp # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    notificationId: ID # representing Courier's request ID, so we can link between our internal system and Courier's (obtained from Courier call)
    emailDestination: String # mostly applicable to email based notifications
    userFullName: String # mostly applicable to email based notifications
    type: NotificationType!
    channelType: NotificationChannelType!
    status: NotificationStatus!
    expoPushTokens: [String] # the push tokens for the user devices that we should send the notification to (applicable only to push notifications)
    ineligibleTransactionAmount: Float, # mostly applicable to push based notifications, representing the cashback given for ineligible notifications
    pendingCashback: Float, # mostly applicable to push based notifications, representing the pending cashback for a qualifying transactional offer
    merchantName: String # mostly applicable to push based notifications, representing the name of the merchant for a qualifying transactional offer
    actionUrl: String # mostly applicable to push based notifications (to indicate what happens when a user taps on the notification)
    createdAt: AWSDateTime # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
    transactions: [MoonbeamTransactionInput] # mostly applicable for email based notifications, representing the transactions used in the daily earnings summary
    dailyEarningsSummaryAmount: Float # mostly applicable for email or push based notifications, representing the daily earnings summary amount
}

# this input is specific for sending email notifications and will be used solely as an input object, outside of any AppSync related queries and/or mutations
input SendEmailNotificationInput {
    emailDestination: String!
    userFullName: String!
    transactions: [MoonbeamTransactionInput]
    dailyEarningsSummaryAmount: Float
}

# this input is specific for sending mobile push notifications and will be used solely as an input object, outside of any AppSync related queries and/or mutations
input SendMobilePushNotificationInput {
    expoPushTokens: [String]!
    pendingCashback: Float
    merchantName: String
    ineligibleTransactionAmount: Float
    dailyEarningsSummaryAmount: Float
}

# this type is a specific response for sending notifications and will be used solely as an input object, outside of any AppSync related queries and/or mutations
type NotificationResponse @aws_cognito_user_pools @aws_api_key {
    requestId: ID # Courier specific request ID
    errorType: NotificationsErrorType
    errorMessage: String
}

type CreateNotificationResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the notification, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: Notification
    errorType: NotificationsErrorType
    errorMessage: String
}

type GetNotificationByTypeResponse @aws_cognito_user_pools @aws_api_key {
    data: [Notification]
    errorType: NotificationsErrorType
    errorMessage: String
}

# this input is specific for sending email notifications and will be used outside of any AppSync related queries and/or mutations
type EmailFromCognitoResponse @aws_cognito_user_pools @aws_api_key {
    data: String
    errorType: NotificationsErrorType
    errorMessage: String
}

type LocationBasedOfferReminderResponse @aws_cognito_user_pools @aws_iam {
    data: NotificationStatus
    errorType: NotificationsErrorType
    errorMessage: String
}

type UserNotificationAssetsResponse @aws_cognito_user_pools @aws_iam {
    data: [UserNotificationsAssets]
    errorType: NotificationsErrorType
    errorMessage: String
}

input CreateLocationBasedOfferReminderInput {
    expoPushToken: [String]!
    latitude: String!
    longitude: String!
}

input GetNotificationByTypeInput {
    type: NotificationType!
    endDate: AWSDateTime! ## the start time to filter notifications for
}

input GetUserNotificationAssetsInput {
    idList: [ID]! # this represents a list of the userIds to be used when retrieving the details of the notification.
}
# graphql/PhysicalDevicesSchema.graphql
# Physical Devices Schema File
enum UserDeviceErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

# signals whether a user is actively using a device or not (if they are signed out, device deleted/replaced etc.)
enum UserDeviceState {
    ACTIVE
    INACTIVE
}

type PushDevice @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the devices belongs to
    tokenId: ID! # this represents the Expo push token ID for a particular physical device
    deviceState: UserDeviceState!
    lastLoginDate: AWSDateTime!
}

type UserDeviceResponse @aws_cognito_user_pools @aws_api_key {
    data: PushDevice
    errorType: UserDeviceErrorType
    errorMessage: String
}

type UserDevicesResponse @aws_cognito_user_pools @aws_api_key {
    data: [PushDevice]
    errorType: UserDeviceErrorType
    errorMessage: String
}

input GetDevicesForUserInput {
    id: ID!
}

input CreateDeviceInput {
    id: ID! # this represents the userID which the devices belongs to
    tokenId: ID! # this represents the Expo push token ID for a particular physical device
    deviceState: UserDeviceState!
    lastLoginDate: AWSDateTime
}
# graphql/OffersSchema.graphql
# Offers Schema File
enum OffersErrorType {
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

enum OfferState {
    pending
    scheduled
    active
    expired
    paused
    archived
}

enum OfferAvailability {
    client_only
    global
    all
}

enum OfferReach {
    state
    national
    online_only
}

enum RedemptionType {
    cardlinked
    click
    mobile
    all
}

enum RedemptionTrigger {
    minimum_purchase_amount,
    purchase_frequency,
    cumulative_purchase_amount
}

enum RewardType {
    fixed
    percentage
    reward_amount
    reward_percent
}

enum CountryCode {
    US
    CA
}

enum OfferSeasonalType {
    VETERANS_DAY
}

enum OfferFilter {
    FIDELIS
    ONLINE
    CATEGORIZED_ONLINE
    NEARBY
    CATEGORIZED_NEARBY
    PREMIER_NEARBY
    PREMIER_ONLINE
    SEASONAL_NEARBY
    SEASONAL_ONLINE
    VETERANS_DAY
}

enum OfferCategory {
    food
    retail
    entertainment
    travel
    automotive
    children_and_family
    electronics
    financial_services
    health_and_beauty
    home
    office_and_business
    utilities_and_telecom
    services_and_subscriptions
    veteran_day
}

# this is an Olive-based object, and therefore since their documentation lacks clarity on which fields are
# required and which fields are not, we will make them all optional
# https://developer.oliveltd.com/reference/the-offer-object
type OfferStoreGeoLocation @aws_cognito_user_pools {
    latitude: Float
    longitude: Float
}

# this is an Olive-based object, and therefore since their documentation lacks clarity on which fields are
# required and which fields are not, we will make them all optional
# https://developer.oliveltd.com/reference/the-offer-object
type OfferStore @aws_cognito_user_pools {
    id: ID
    name: String
    phone: String
    address1: String
    city: String
    state: String
    countryCode: CountryCode
    postCode: String
    geoLocation: OfferStoreGeoLocation
    isOnline: Boolean
    distance: Float
}

# this is an Olive-based object, and therefore since their documentation lacks clarity on which fields are
# required and which fields are not, we will make them all optional
# https://developer.oliveltd.com/reference/the-offer-object
type Reward @aws_cognito_user_pools {
    type: RewardType
    value: Float
    maxValue: Float
}

# this is an Olive-based object, and therefore since their documentation lacks clarity on which fields are
# required and which fields are not, we will make them all optional
# https://developer.oliveltd.com/reference/the-offer-object
type Offer @aws_cognito_user_pools {
    id:	ID
    corporateId: ID
    created: AWSDateTime
    offerState:	OfferState
    availability: OfferAvailability
    brandId: ID
    brandDba: String
    brandLogo: String
    brandLogoSm: String
    brandBanner: String
    brandWebsite: String
    brandParentCategory: String
    brandStubCopy: String
    storeDetails: [OfferStore]
    description: String
    reach: OfferReach
    title: String
    qualifier: String
    tile: String
    startDate: AWSDateTime
    endDate: AWSDateTime
    currency: CurrencyCodeType
    extOfferId: ID
    supplierOfferKey: ID
    redemptionType: RedemptionType
    redemptionInstructionUrl: String
    redemptionTrigger: RedemptionTrigger
    budget: Float
    daysAvailability: [Int]
    stores: [ID]
    totalRedeemLimit: Int
    redeemLimitPerUser:	Int
    purchaseAmount:	Float
    purchaseFrequency: Int
    reward: Reward
}

type OffersPaginatedResponse @aws_cognito_user_pools {
    totalNumberOfPages: Int!
    totalNumberOfRecords: Int!
    offers: [Offer]!
}

type FidelisPartner @aws_cognito_user_pools {
    brandName: String!
    veteranOwned: Boolean!
    numberOfOffers: Int!
    offers: [Offer]!
}

type OffersResponse @aws_cognito_user_pools {
    data: OffersPaginatedResponse
    errorType: OffersErrorType
    errorMessage: String
}

type FidelisPartnerResponse @aws_cognito_user_pools {
    data: [FidelisPartner]
    errorType: OffersErrorType
    errorMessage: String
}

input GetOffersInput {
    filterType: OfferFilter!
    availability: OfferAvailability!
    offerStates: [OfferState]!
    countryCode: CountryCode!
    redemptionType: RedemptionType!
    pageSize: Int!
    pageNumber: Int!
    brandName: String
    offerCategory: OfferCategory
    radiusLatitude: Float # required only when the offer filter is NEARBY, PREMIER_NEARBY, CATEGORIZED_NEARBY or SEASONAL_NEARBY
    radiusLongitude: Float # required only when the offer filter is NEARBY, PREMIER_NEARBY, CATEGORIZED_NEARBY or SEASONAL_NEARBY
    radius: Int # required only when the offer filter is NEARBY, PREMIER_NEARBY, CATEGORIZED_NEARBY or SEASONAL_NEARBY
    radiusIncludeOnlineStores: Boolean # required only when the offer filter is NEARBY, PREMIER_NEARBY, CATEGORIZED_NEARBY or SEASONAL_NEARBY
    offerSeasonalType: OfferSeasonalType # required only when the offer filter is SEASONAL_NEARBY or SEASONAL_ONLINE
}

input SearchOffersInput {
    searchText: String! # this can include a category or name of brand, e.g ('food', 'drinks' or 'Nike').
    radiusLatitude: Float
    radiusLongitude: Float
    radius: Int
}

# graphql/FAQSchema.graphql
# FAQ Schema File
enum FAQErrorType {
    DUPLICATE_OBJECT_FOUND
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum FactType {
    LINKABLE
    NON_LINKABLE
}

type Fact @aws_cognito_user_pools {
    description: String!
    linkableKeyword: String # only applicable if the type of the Fact is LINKABLE
    linkLocation: String # only applicable if the type of the Fact is LINKABLE
    type: FactType!
}

type FAQ @aws_cognito_user_pools {
    id: ID!
    title: String!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    facts: [Fact]!
}

type FAQResponse @aws_cognito_user_pools {
    data: [FAQ]
    errorType: FAQErrorType
    errorMessage: String
}

input FactInput {
    description: String!
    linkableKeyword: String # only applicable if the type of the Fact is LINKABLE
    linkLocation: String # only applicable if the type of the Fact is LINKABLE
    type: FactType!
}

input CreateFAQInput {
    id: ID
    title: String!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
    facts: [FactInput]!
}
# graphql/UserAuthSessionSchema.graphql
# User Auth Session Schema File
enum UserAuthSessionErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

type UserAuthSession @aws_cognito_user_pools {
    id: ID! # this represents the userID which the authentication session belongs to
    createdAt: AWSDateTime! # this represents the first time that the user logged in at
    updatedAt: AWSDateTime! # this represents the last time that the user logged in at
    numberOfSessions: Int!
}

input CreateUserAuthSessionInput {
    id: ID!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}

input GetUserAuthSessionInput {
    id: ID!
}

input UpdateUserAuthSessionInput {
    id: ID!
    updatedAt: AWSDateTime
}

type UserAuthSessionResponse @aws_cognito_user_pools {
    data: UserAuthSession
    errorType: UserAuthSessionErrorType
    errorMessage: String
}
# graphql/NotificationReminderSchema.graphql
# Notification Reminder Schema File
enum NotificationReminderErrorType {
    DUPLICATE_OBJECT_FOUND
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum NotificationReminderType {
    CARD_LINKING_REMINDER
    NEW_MAP_FEATURE_REMINDER
    VETERANS_DAY_TEMPLATE_1_REMINDER
    VETERANS_DAY_TEMPLATE_2_REMINDER
    VETERANS_DAY_TEMPLATE_3_REMINDER
    REFERRAL_TEMPLATE_LAUNCH
    REFERRAL_TEMPLATE_1_REMINDER
    REFERRAL_TEMPLATE_2_REMINDER
    REFERRAL_TEMPLATE_3_REMINDER
    MULTIPLE_CARD_FEATURE_REMINDER
    SPOUSE_FEATURE_REMINDER
    FEEDBACK_TEMPLATE_1_REMINDER
    LOCATION_BASED_OFFER_REMINDER
    SAN_ANTONIO_REFERRAL_TEMPLATE_1_REMINDER
    REIMBURSEMENTS_REMINDER
    SPENDING_TEMPLATE_1_REMINDER
}

enum NotificationReminderStatus {
    ACTIVE
    INACTIVE
}

enum NotificationReminderCadence {
    ONE_TIME
    DAILY
    WEEKLY
    BI_WEEKLY
    MONTHLY
}

type NotificationReminder @aws_cognito_user_pools @aws_api_key {
    id: ID!
    notificationReminderType: NotificationReminderType!
    notificationReminderStatus: NotificationReminderStatus!
    notificationReminderCadence: NotificationReminderCadence!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    # this will automatically schedule the notification reminder to start the next business day, on the agreed cadence
    nextTriggerAt: AWSDateTime!
    notificationChannelType: [NotificationChannelType]!
    # this represents the number of times that this notification reminder was triggered
    notificationReminderCount: Int!
    # this represents the number of time that this notification reminder can run - we default to 999,999 times as our INDEFINITE number
    notificationReminderMaxCount: Int!
}

type UserDetailsForNotifications @aws_cognito_user_pools @aws_api_key {
    id: ID!
    email: String!
    firstName: String!
    lastName: String!
    notificationChannelType: [NotificationChannelType]!
    notificationType: NotificationType!
}

type NotificationReminderResponse @aws_cognito_user_pools @aws_api_key {
    data: [NotificationReminder]
    errorType: NotificationReminderErrorType
    errorMessage: String
}

type UserForNotificationReminderResponse @aws_cognito_user_pools @aws_api_key {
    data: [RetrieveUserDetailsForNotifications]
    errorType: NotificationReminderErrorType
    errorMessage: String
}

input CreateNotificationReminderInput {
    id: ID
    notificationReminderType: NotificationReminderType!
    notificationReminderStatus: NotificationReminderStatus!
    notificationReminderCadence: NotificationReminderCadence!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
    nextTriggerAt: AWSDateTime
    notificationChannelType: [NotificationChannelType]!
    notificationReminderCount: Int
    notificationReminderMaxCount: Int
}

input UpdateNotificationReminderInput {
    id: ID!
    notificationReminderStatus: NotificationReminderStatus!
    updatedAt: AWSDateTime
}

input GetUsersByGeographicalLocationInput {
    zipCodes: [String]!
}

# graphql/AppUpgradeSchema.graphql
# App Upgrade Schema File
enum AppUpgradeErrorType {
    DUPLICATE_OBJECT_FOUND
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

type AppUpgradeResponse @aws_cognito_user_pools @aws_api_key {
    data: String
    errorType: AppUpgradeErrorType
    errorMessage: String
}
# graphql/Referral.graphql
# Referral Schema File
enum ReferralErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

# Defines the status for the referrals. For the most part this is pretty self-explanatory:
# PENDING - the referral has been accounted for internally but not all qualifying terms have been met yet
# VALID - the referral has been accounted for internally and all qualifying terms have been met
# INVALID - the referral has been accounted for internally and the qualifying terms have not been met/have expired
# REDEEMED - the referral has been accounted for internally and the member has used it to redeem their prize
enum ReferralStatus {
    PENDING
    VALID
    INVALID
    REDEEMED
}

# Defines the different marketing campaign codes which will help us understand what campaign this referral has been a
# part of.
enum MarketingCampaignCode {
    RAFFLEREGDEC23
    RAFFLEREGJAN24
    RAFFLEREGFEB24
    RAFFLEREGMAR24
    RAFFLEREGAPR24
    RAFFLEREGJUN24
    RAFFLEREGAUG24
    RAFFLEREGOCT24
    RAFFLEREGDEC24
    SUNNYACTUAL1
    MILBILBOARD1
}

# The referral object which will get stored in the Referrals table
type Referral @aws_api_key @aws_cognito_user_pools {
    fromId: ID! # this represents the userID of the user who made the referral
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    toId: ID!  # this represents the userID of the user who got referred
    campaignCode: MarketingCampaignCode!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    status: ReferralStatus!
}

type ReferralResponse @aws_cognito_user_pools @aws_api_key {
    data: [Referral]
    errorType: ReferralErrorType
    errorMessage: String
}

type UserFromReferralResponse @aws_cognito_user_pools @aws_api_key {
    data: ID # this represents the userID of the user who made the referral
    errorType: ReferralErrorType
    errorMessage: String
}

input GetReferralsByStatusInput {
    status: ReferralStatus!
}

input CreateReferralInput {
    fromId: ID!
    toId: ID!
    campaignCode: MarketingCampaignCode!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}

input UpdateReferralInput {
    fromId: ID!
    timestamp: AWSTimestamp!
    status: ReferralStatus!
    updatedAt: AWSDateTime
}

input UserFromReferralInput {
    referralCode: ID! # this represents the referral code of the user who refers ({lastName}-{firstOfFirstName}-{CRC32(userId)})
}


# graphql/LoggingSchema.graphql
# Logging Schema File
enum LoggingErrorType {
    DUPLICATE_OBJECT_FOUND
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum LoggingLevel {
    INFO
    DEBUG
    WARNING
    ERROR
}

enum LoggingAcknowledgmentType {
    SUCCESSFUL
    ERROR
}

type LoggingResponse @aws_cognito_user_pools @aws_iam {
    data: LoggingAcknowledgmentType
    errorType: LoggingErrorType
    errorMessage: String
}

input CreateLogEventInput {
    message: String!
    logLevel: LoggingLevel!
}
# graphql/MilitaryVerificationReportingSchema.graphql
# Military Verification Reporting Schema File
enum MilitaryVerificationReportingErrorType {
    UNPROCESSABLE
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

type MilitaryVerificationReportingInformation @aws_cognito_user_pools @aws_api_key {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
    militaryVerificationStatus: MilitaryVerificationStatusType!
    phoneNumber: String
    emailAddress: String
}

type MilitaryVerificationReportingInformationResponse @aws_cognito_user_pools @aws_api_key {
    data: [MilitaryVerificationReportingInformation]
    errorType: MilitaryVerificationReportingErrorType
    errorMessage: String
}
# graphql/AppReviewSchema.graphql
# App Review Schema File
enum AppReviewErrorType {
    DUPLICATE_OBJECT_FOUND
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

type AppReview @aws_cognito_user_pools {
    id: ID! # represents the internal Moonbeam user id
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
}

type GetAppReviewEligibilityResponse @aws_cognito_user_pools {
    data: Boolean
    errorType: AppReviewErrorType
    errorMessage: String
}

type AppReviewResponse @aws_cognito_user_pools {
    data: AppReview
    errorType: AppReviewErrorType
    errorMessage: String
}

input GetAppReviewEligibilityInput {
    id: ID! # represents the internal Moonbeam user id
}

input CreateAppReviewInput {
    id: ID! # represents the internal Moonbeam user id
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}
# graphql/UtilitiesSchema.graphql
# Utilities Schema File
enum OSType {
    IOS,
    ANDROID
}

enum UtilitiesErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    RESTRICTED_ACCESS
}

type Location @aws_cognito_user_pools {
    latitude: Float!,
    longitude: Float!
}

type GeocodeAsyncResponse @aws_cognito_user_pools {
    data: [Location]
    errorType: UtilitiesErrorType
    errorMessage: String
}

type GetLocationPredictionsResponse @aws_iam @aws_cognito_user_pools {
    data: [LocationPredictionType]
    errorType: UtilitiesErrorType
    errorMessage: String
}

type LocationPredictionType @aws_iam @aws_cognito_user_pools {
    description: String
    place_id: String
    reference: String
    matched_substrings: String # this will be any[] converted through JSON.stringify(any[])
    structured_formatting: String # this will be an Object converted through JSON.stringify(Object)
    address_components: String # this will be any[] converted through JSON.stringify(any[])
    terms: String #this will be Object[] converted through JSON.stringify(Object[])
    types: [String]

}

input GetLocationPredictionsInput {
    address: String!,
    osType: OSType!
}

input GeocodeAsyncInput {
    address: String!,
    osType: OSType!
}
# graphql/ReimbursementsSchema.graphql
# Reimbursements Schema File
enum ReimbursementsErrorType {
    DUPLICATE_OBJECT_FOUND
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum ReimbursementStatus {
    PROCESSED
    REJECTED
    DECLINED
    PENDING
}

enum ReimbursementProcessingStatus {
    SUCCESS
    FAILED
}

type Reimbursement @aws_cognito_user_pools {
    id: ID! ## this represents the userID which the reimbursement was made by
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    reimbursementId: ID! ## this is an internal id for the reimbursements which is used to link with payout systems like Olive, Stripe, etc.
    createdAt: AWSDateTime! ## this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    status: ReimbursementStatus!
    amount: Float!
    cardId: String!
    cardLast4: String!
    cardType: CardType!
    transactions: [Transaction]!
}

input GetReimbursementsInput {
    id: ID! ## this represents the userID which we are retrieving the reimbursements for
    startDate: AWSDateTime ## the start time to filter reimbursements for
    endDate: AWSDateTime! ## the end time to filter reimbursements for
}

input CreateReimbursementInput {
    id: ID! ## this represents the userID which the reimbursement was made by
    timestamp: AWSTimestamp ## this represents the timestamp, in a Number epoch based format (for sorting purposes)
    reimbursementId: ID ## this is an internal id for the reimbursements which is used to link with payout systems like Olive, Stripe, etc.
    createdAt: AWSDateTime ## this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
    status: ReimbursementStatus!
    amount: Float!
    cardId: String!
    cardLast4: String!
    cardType: CardType!
    transactions: [CreateTransactionInput]!
}

type ReimbursementResponse @aws_cognito_user_pools {
    data: [Reimbursement]
    errorType: ReimbursementsErrorType
    errorMessage: String
}

type ReimbursementProcessingResponse @aws_cognito_user_pools {
    data: ReimbursementProcessingStatus
    errorType: ReimbursementsErrorType
    errorMessage: String
}
# graphql/ServicesSchema.graphql
# Services Schema File
enum ServicesErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

enum ServicePartnerStatus {
    ACTIVE
    INACTIVE
}

type Service @aws_cognito_user_pools {
    title: String!
    description: String!
}

type Partner @aws_cognito_user_pools {
    id: ID!
    status: ServicePartnerStatus!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    name: String!
    shortDescription: String!
    description: String!
    isOnline: Boolean!
    logoUrl: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    website: String!
    services: [Service]!
    email: String
    phoneNumber: String
}

type PartnerResponse @aws_cognito_user_pools {
    data: [Partner]
    errorType: ServicesErrorType
    errorMessage: String
}

input ServiceInput {
    title: String!
    description: String!
}

input CreatePartnerInput {
    id: ID
    status: ServicePartnerStatus
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
    name: String!
    shortDescription: String!
    description: String!
    isOnline: Boolean!
    logoUrl: String
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    website: String!
    services: [ServiceInput]!
    email: String
    phoneNumber: String
}
# graphql/EventsSchema.graphql
# Events Schema File
enum EventsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
}

enum EventSeriesStatus {
    ACTIVE
    INACTIVE
}

type EventStartDateTime @aws_cognito_user_pools @aws_api_key {
    timezone: String!
    startsAtLocal: AWSDateTime!
    startsAtUTC: AWSDateTime!
}

type EventEndDateTime @aws_cognito_user_pools @aws_api_key {
    timezone: String!
    endsAtLocal: AWSDateTime!
    endsAtUTC: AWSDateTime!
}

type Event @aws_cognito_user_pools @aws_api_key {
    id: ID!
    externalEventID: ID!
    title: String!
    description: String!
    eventLogoUrlSm: String!
    eventLogoUrlBg: String!
    startTime: EventStartDateTime!
    endTime: EventEndDateTime!
    registrationUrl: String!
}

type EventSeries @aws_cognito_user_pools @aws_api_key {
    id: ID!
    externalSeriesID: ID!
    externalOrgID: ID!
    name: String!
    title: String!
    description: String!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    events: [Event]!
    seriesLogoUrlSm: String!
    seriesLogoUrlBg: String!
    status: EventSeriesStatus!
}

type EventSeriesResponse @aws_cognito_user_pools @aws_api_key {
    data: [EventSeries]
    errorType: EventsErrorType
    errorMessage: String
}

input CreateEventSeriesInput {
    name: String!
    externalSeriesID: ID
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}
# graphql/DailySummarySchema.graphql
# Daily Summary Schema File
enum DailySummaryErrorType {
    DUPLICATE_OBJECT_FOUND
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum DailyEarningsSummaryStatus {
    SENT
    ACKNOWLEDGED
}

type DailyEarningsSummary @aws_cognito_user_pools @aws_api_key {
    id: ID! ## this represents the userID which the daily earnings summary was made for.
    timestamp: AWSTimestamp! ## this represents the timestamp, in a Number epoch based format (for sorting purposes) to represent the beginning of the day
    dailyEarningsSummaryID: ID! ## this is an internal id for daily summaries.
    createdAt: AWSDateTime! ## this represents the creation date but will also be used for sorting purposes.
    updatedAt: AWSDateTime!
    status: DailyEarningsSummaryStatus!
    transactions: [MoonbeamTransaction]!
}

type DailyEarningsSummaryResponse @aws_cognito_user_pools @aws_api_key {
    data: [DailyEarningsSummary]
    errorType: DailySummaryErrorType
    errorMessage: String
}

input CreateDailyEarningsSummaryInput {
    targetDate: AWSDateTime! ## this represents the date used to create the daily earnings summary for
}

input GetDailyEarningsSummaryInput {
    id: ID! ## the userID which which the daily earnings summary was made for.
    targetDate: AWSDateTime! ## this represents the date used to sort and retrieve the appropriate daily earnings summary for.
}

input UpdateDailyEarningsSummaryInput {
    id: ID! ## the userID which which the daily earnings summary was made for.
    targetDate: AWSDateTime! ## this represents the date used to sort and retrieve the appropriate daily earnings summary for.
    status: DailyEarningsSummaryStatus!
}

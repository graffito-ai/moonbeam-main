# graphql/Root.graphql
# Main Schema File
type Query {
    getTransaction(getTransactionInput: GetTransactionInput!): MoonbeamTransactionsResponse! @aws_cognito_user_pools
    getReimbursementByStatus(getReimbursementByStatusInput: GetReimbursementByStatusInput!): ReimbursementByStatusResponse! @aws_cognito_user_pools @aws_api_key
    getTransactionByStatus(getTransactionByStatusInput: GetTransactionByStatusInput!): MoonbeamTransactionsByStatusResponse! @aws_cognito_user_pools @aws_api_key
    getCardLink(getCardLinkInput: GetCardLinkInput!): CardLinkResponse! @aws_cognito_user_pools
    getStorage(getStorageInput: GetStorageInput!): StorageResponse! @aws_cognito_user_pools
    getMilitaryVerificationStatus(getMilitaryVerificationInput: GetMilitaryVerificationInput!): GetMilitaryVerificationResponse! @aws_cognito_user_pools
    getEligibleLinkedUsers: EligibleLinkedUsersResponse! @aws_cognito_user_pools @aws_api_key
}

type Mutation {
    addCard(addCardInput: AddCardInput!): CardLinkResponse! @aws_cognito_user_pools
    createReimbursementEligibility(createReimbursementEligibilityInput: CreateReimbursementEligibilityInput!): ReimbursementEligibilityResponse! @aws_cognito_user_pools @aws_api_key
    updateReimbursementEligibility(updateReimbursementEligibilityInput: UpdateReimbursementEligibilityInput!): ReimbursementEligibilityResponse! @aws_cognito_user_pools @aws_api_key
    createReimbursement(createReimbursementInput: CreateReimbursementInput!): ReimbursementResponse! @aws_cognito_user_pools @aws_api_key
    updateReimbursement(updateReimbursementInput: UpdateReimbursementInput!): ReimbursementResponse! @aws_cognito_user_pools @aws_api_key
    createTransaction(createTransactionInput: CreateTransactionInput!): MoonbeamTransactionResponse! @aws_cognito_user_pools @aws_api_key
    updateTransaction(updateTransactionInput: UpdateTransactionInput!): MoonbeamUpdatedTransactionResponse! @aws_cognito_user_pools @aws_api_key
    createCardLink(createCardLinkInput: CreateCardLinkInput!): CardLinkResponse! @aws_cognito_user_pools
    deleteCard(deleteCardInput: DeleteCardInput!): CardResponse! @aws_cognito_user_pools
    updateMilitaryVerificationStatus(updateMilitaryVerificationInput: UpdateMilitaryVerificationInput!): UpdateMilitaryVerificationResponse! @aws_cognito_user_pools
    createMilitaryVerification(createMilitaryVerificationInput: CreateMilitaryVerificationInput!): CreateMilitaryVerificationResponse! @aws_cognito_user_pools
}

type Subscription {
    updatedMilitaryVerificationStatus(id: ID!): UpdateMilitaryVerificationResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["updateMilitaryVerificationStatus"])
    createdTransaction(id: ID!): MoonbeamTransactionResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["createTransaction"])
}
# graphql/AccountLinkSchema.graphql
# Storage Schema File
enum StorageErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    RESTRICTED_ACCESS
}

# Defines the types of file access levels available, implemented in line with what
# Amplify storage does.
#
# For more information, refer to:
# https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/
#
# For now just considering the public and private access levels, not protected.
enum FileAccessLevel {
    PUBLIC
    PRIVATE
    PROTECTED
}

# Defines the type of file to retrieve, which then, in turn determines the bucket that we
# read from, and implicitly, the CloudFront distribution that we read from.
enum FileType {
    MAIN
    # TBD on more file types, depending on whether we want to have additional buckets or not
}

type File @aws_cognito_user_pools {
    url: String!
}

type StorageResponse @aws_cognito_user_pools {
    data: File
    errorType: StorageErrorType
    errorMessage: String
}

input GetStorageInput {
    id: String,
    level: FileAccessLevel!,
    type: FileType!,
    name: String!,
    expires: Boolean
}
# graphql/MilitaryVerificationSchema.graphql
# Military Verification Schema File
enum MilitaryVerificationErrorType {
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum MilitaryVerificationStatusType {
    VERIFIED
    PENDING
    REJECTED
}

enum MilitaryDutyStatus {
    ACTIVE_DUTY
    NATIONAL_GUARD
    RESERVIST
    VETERAN
}

enum MilitaryBranch {
    AIR_FORCE
    ARMY
    COAST_GUARD
    MARINE_CORPS
    NAVY
    SPACE_FORCE
}

enum MilitaryAffiliation {
    SERVICE_MEMBER
    FAMILY_SPOUSE
    FAMILY_CHILD
    FAMILY_SIBLING
    FAMILY_PARENT
}

type MilitaryVerificationInformation @aws_cognito_user_pools {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
    militaryVerificationStatus: MilitaryVerificationStatusType!
}

type MilitaryVerificationStatus @aws_cognito_user_pools {
    id: ID!
    militaryVerificationStatus: MilitaryVerificationStatusType!
}

type CreateMilitaryVerificationResponse @aws_cognito_user_pools {
    data: MilitaryVerificationInformation
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type GetMilitaryVerificationResponse @aws_cognito_user_pools {
    data: MilitaryVerificationStatus
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type UpdateMilitaryVerificationResponse @aws_cognito_user_pools {
    id: ID
    militaryVerificationStatus: MilitaryVerificationStatusType
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

input UpdateMilitaryVerificationInput {
    id: ID!
    militaryVerificationStatus: MilitaryVerificationStatusType!
    updatedAt: AWSDateTime
}

input GetMilitaryVerificationInput {
    id: ID!
}

input CreateMilitaryVerificationInput {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
}
# graphql/CardLinkingSchema.graphql
# Card Linking Schema File
enum CardLinkErrorType {
    ALREADY_EXISTENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
    INVALID_CARD_SCHEME
}

enum CardType {
    MASTERCARD
    VISA
    INVALID
}

enum CardLinkingStatus {
    LINKED
    NOT_LINKED
}

type EligibleLinkedUser @aws_cognito_user_pools @aws_api_key {
    id: ID!
    memberId: ID!
    cardId: ID!
}

type Card @aws_cognito_user_pools {
    id: ID! # this will be obtained from Olive (and it is the Olive card id)
    applicationID: ID! # this will be passed on to Olive as the enrollment ID (referenceAppId)
    token: String!
    type: CardType!
    name: String!
    last4: String!
    additionalProgramID: String # not all card will have additional program IDs enrolled to them
}

type CardLink @aws_cognito_user_pools {
    id: ID! # this will be passed on to Olive as the unique user ID (extMemberId), and represents Moonbeam's unique user ID
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cards: [Card]!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    status: CardLinkingStatus! # to keep track of whether a card is linked or not, for faster fetching purposes
}

type Member @aws_cognito_user_pools {
    id: ID!
    memberId: ID!
    isActive: Boolean
}

type CardUpdate @aws_cognito_user_pools {
    id: ID!
    cardId: ID!
    updatedAt: AWSDateTime!
}

input CardInput {
    applicationID: ID # not required since this will be generated on the back-end
    token: String!
    type: CardType!
    name: String!
    last4: String!
    additionalProgramID: String # not required since cards will mainly only be enrolled into the default program ID for Moonbeam through Olive
}

input CreateCardLinkInput {
    id: ID!
    card: CardInput!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}

input AddCardInput {
    id: ID!
    memberId: ID!
    card: CardInput!
    updatedAt: AWSDateTime
}

input GetCardLinkInput {
    id: ID!
}

input DeleteCardInput {
    id: ID!
    memberId: ID!
    cardId: ID!
    updatedAt: AWSDateTime
}

type CardResponse @aws_cognito_user_pools {
    data: CardUpdate
    errorType: CardLinkErrorType
    errorMessage: String
}

type CardLinkResponse @aws_cognito_user_pools {
    data: CardLink
    errorType: CardLinkErrorType
    errorMessage: String
}

type MemberResponse @aws_cognito_user_pools {
    data: Member
    errorType: CardLinkErrorType
    errorMessage: String
}

type RemoveCardResponse @aws_cognito_user_pools {
    data: Boolean
    errorType: CardLinkErrorType
    errorMessage: String
}

type EligibleLinkedUsersResponse @aws_cognito_user_pools @aws_api_key {
    data: [EligibleLinkedUser]
    errorType: CardLinkErrorType
    errorMessage: String
}
# graphql/TransactionsSchema.graphql
# Transactions Schema File
enum TransactionsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    UNPROCESSABLE
}

# Defines the types of the statuses for a transaction, during its lifecycle. Although these
# statuses might not match Olive's statuses 1:1, they represent what our customers see in their
# dashboard, and how we translate incoming Olive information, and communicate it to our end
# users.
enum TransactionsStatus {
    PENDING
    PROCESSED
    CREDITED
    REJECTED
}

# Defines the type of transactions that are available, depending on incoming information received
# through the Olive webhooks. The transactions processor, will handle these transaction types and
# determine whether they are offers to be redeemed, round-ups, contributions/matching, etc.
enum TransactionType {
    OFFER_REDEEMED
    ROUNDUP
    CONTRIBUTION
}

# For now we only support USD as the currency code type for transactions
enum CurrencyCodeType {
    USD
}

# this type is mainly used to define and/or work with the Transaction object before it is stored
# in the DB, as obtained from Olive.
type Transaction @aws_cognito_user_pools {
    id: ID # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float,
    totalAmount: Float,
    pendingCashbackAmount: Float # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String,
    transactionBrandAddress: String,
    transactionBrandLogoUrl: String,
    transactionBrandURLAddress: String,
    transactionIsOnline: Boolean
}

# this type is mainly used to define and/or work with the TransactionResponse object before it is stored
# in the DB, as obtained from Olive's get transaction details call - used for transactional purposes.
type TransactionResponse @aws_cognito_user_pools @aws_api_key {
    data: Transaction
    errorType: TransactionsErrorType
    errorMessage: String
}

# this type is mainly used to define and/or work with the TransactionStatusResponse object before it is stored
# in the DB, as obtained from Olive's get transaction details call - used for reimbursement purposes.
type TransactionStatusResponse @aws_cognito_user_pools @aws_api_key {
    oliveTransactionStatus: String
    errorType: TransactionsErrorType
    errorMessage: String
}

type MemberDetailsResponse @aws_cognito_user_pools @aws_api_key {
    data: String
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}

type MoonbeamUpdatedTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    updatedAt: AWSDateTime!
}

type MoonbeamTransactionByStatus @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp!
    transactionId: ID!
    transactionStatus: TransactionsStatus!
}

type MoonbeamTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransactionsResponse @aws_cognito_user_pools {
    data: [MoonbeamTransaction]
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransactionsByStatusResponse @aws_cognito_user_pools @aws_api_key {
    data: [MoonbeamTransactionByStatus]
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamUpdatedTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamUpdatedTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

input GetTransactionInput {
    id: ID! #this represents the userID which the transactions should be retrieved for
    startDate: AWSDateTime # the start time to filter transactions for
    endDate: AWSDateTime! # the end time to filter transactions for
}

input GetTransactionByStatusInput {
    id: ID! # this represents the userID which the transactions should be retrieved for
    status: TransactionsStatus! # the transactions status to filter transactions for
}

input UpdateTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    updatedAt: AWSDateTime!
}

input CreateTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!,
    transactionBrandURLAddress: String!,
    transactionIsOnline: Boolean!
}
# graphql/ReimbursementsSchema.graphql
# Reimbursements Schema File
enum ReimbursementsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    UNPROCESSABLE
}

# Defines the types of the statuses for a reimbursement, during its lifecycle. Although these
# statuses might not match Olive's statuses 1:1, they represent what our customers see in their
# dashboard, and how we translate incoming Olive information, and communicate it to our end
# users.
enum ReimbursementStatus {
    PENDING
    PROCESSED
    FAILED
}

# Defines the status for a user's reimbursement eligibility.
enum ReimbursementEligibilityStatus {
    ELIGIBLE
    INELIGIBLE
}

type ReimbursementTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
}

type ReimbursementEligibility @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    eligibilityStatus: ReimbursementEligibilityStatus!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime!
}

type Reimbursement @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    reimbursementId: ID!, # Olive specific
    clientId: ID, # Olive specific
    paymentGatewayId: ID, # Olive specific
    succeeded: Boolean, # this will only be applicable is the status is PROCESSED or FAILED
    processingMessage: String # this will only be applicable is the status is PROCESSED or FAILED so we know why something failed or succeeded
    cardId: ID!,
    reimbursementStatus: ReimbursementStatus!
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    currencyCode: CurrencyCodeType!,
    transactions:  [ReimbursementTransaction]! # this array associates particular transactions to a reimbursement object, so we know what was reimbursed to customers
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
}

type ReimbursementByStatusResponse @aws_cognito_user_pools @aws_api_key {
    data: [Reimbursement]
    errorType: ReimbursementsErrorType
    errorMessage: String
}

type ReimbursementResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the reimbursement, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: Reimbursement
    errorType: ReimbursementsErrorType
    errorMessage: String
}

type ReimbursementEligibilityResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the reimbursement eligibility, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: ReimbursementEligibility
    errorType: ReimbursementsErrorType
    errorMessage: String
}

input ReimbursementTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
}

input CreateReimbursementEligibilityInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    eligibilityStatus: ReimbursementEligibilityStatus!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}

input UpdateReimbursementEligibilityInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    eligibilityStatus: ReimbursementEligibilityStatus!
    updatedAt: AWSDateTime
}

input GetReimbursementByStatusInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    reimbursementStatus: ReimbursementStatus!
}

input CreateReimbursementInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    reimbursementId: ID!, # Olive specific
    clientId: ID, # Olive specific
    paymentGatewayId: ID, # Olive specific
    succeeded: Boolean, # this will only be applicable is the status is PROCESSED or FAILED
    processingMessage: String # this will only be applicable is the status is PROCESSED or FAILED so we know why something failed or succeeded
    cardId: ID!,
    reimbursementStatus: ReimbursementStatus!
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    currencyCode: CurrencyCodeType!,
    transactions:  [ReimbursementTransactionInput]! # this array associates particular transactions to a reimbursement object, so we know what was reimbursed to customers
    createdAt: AWSDateTime # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
}

input UpdateReimbursementInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    clientId: ID, # Olive specific
    paymentGatewayId: ID, # Olive specific
    succeeded: Boolean, # this will only be applicable is the status is PROCESSED or FAILED
    processingMessage: String # this will only be applicable is the status is PROCESSED or FAILED so we know why something failed or succeeded
    reimbursementStatus: ReimbursementStatus
    pendingCashbackAmount: Float # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactions: [ReimbursementTransactionInput] # this array associates particular transactions to a reimbursement object, so we know what was reimbursed to customers
    updatedAt: AWSDateTime
}

# graphql/Root.graphql
# Main Schema File
type Query {
    getCardLink(getCardLinkInput: GetCardLinkInput!): CardLinkResponse! @aws_cognito_user_pools
    getStorage(getStorageInput: GetStorageInput!): StorageResponse! @aws_cognito_user_pools
    getMilitaryVerificationStatus(getMilitaryVerificationInput: GetMilitaryVerificationInput!): GetMilitaryVerificationResponse! @aws_cognito_user_pools
}

type Mutation {
    addCard(addCardInput: AddCardInput!): CardLinkResponse! @aws_cognito_user_pools
    createTransaction(createTransactionInput: CreateTransactionInput!): MoonbeamTransactionResponse! @aws_cognito_user_pools @aws_api_key
    createCardLink(createCardLinkInput: CreateCardLinkInput!): CardLinkResponse! @aws_cognito_user_pools
    deleteCard(deleteCardInput: DeleteCardInput!): CardResponse! @aws_cognito_user_pools
    updateMilitaryVerificationStatus(updateMilitaryVerificationInput: UpdateMilitaryVerificationInput!): UpdateMilitaryVerificationResponse! @aws_cognito_user_pools
    createMilitaryVerification(createMilitaryVerificationInput: CreateMilitaryVerificationInput!): CreateMilitaryVerificationResponse! @aws_cognito_user_pools
}

type Subscription {
    updatedMilitaryVerificationStatus(id: ID!): UpdateMilitaryVerificationResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["updateMilitaryVerificationStatus"])
    createdTransaction(id: ID!): MoonbeamTransactionResponse @aws_cognito_user_pools @aws_subscribe(mutations: ["createTransaction"])
}
# graphql/AccountLinkSchema.graphql
# Storage Schema File
enum StorageErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    RESTRICTED_ACCESS
}

# Defines the types of file access levels available, implemented in line with what
# Amplify storage does.
#
# For more information, refer to:
# https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/
#
# For now just considering the public and private access levels, not protected.
enum FileAccessLevel {
    PUBLIC
    PRIVATE
    PROTECTED
}

# Defines the type of file to retrieve, which then, in turn determines the bucket that we
# read from, and implicitly, the CloudFront distribution that we read from.
enum FileType {
    MAIN
    # TBD on more file types, depending on whether we want to have additional buckets or not
}

type File @aws_cognito_user_pools {
    url: String!
}

type StorageResponse @aws_cognito_user_pools {
    data: File
    errorType: StorageErrorType
    errorMessage: String
}

input GetStorageInput {
    id: String,
    level: FileAccessLevel!,
    type: FileType!,
    name: String!,
    expires: Boolean
}
# graphql/MilitaryVerificationSchema.graphql
# Military Verification Schema File
enum MilitaryVerificationErrorType {
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
}

enum MilitaryVerificationStatusType {
    VERIFIED
    PENDING
    REJECTED
}

enum MilitaryDutyStatus {
    ACTIVE_DUTY
    NATIONAL_GUARD
    RESERVIST
    VETERAN
}

enum MilitaryBranch {
    AIR_FORCE
    ARMY
    COAST_GUARD
    MARINE_CORPS
    NAVY
    SPACE_FORCE
}

enum MilitaryAffiliation {
    SERVICE_MEMBER
    FAMILY_SPOUSE
    FAMILY_CHILD
    FAMILY_SIBLING
    FAMILY_PARENT
}

type MilitaryVerificationInformation @aws_cognito_user_pools {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
    militaryVerificationStatus: MilitaryVerificationStatusType!
}

type MilitaryVerificationStatus @aws_cognito_user_pools {
    id: ID!
    militaryVerificationStatus: MilitaryVerificationStatusType!
}

type CreateMilitaryVerificationResponse @aws_cognito_user_pools {
    data: MilitaryVerificationInformation
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type GetMilitaryVerificationResponse @aws_cognito_user_pools {
    data: MilitaryVerificationStatus
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

type UpdateMilitaryVerificationResponse @aws_cognito_user_pools {
    id: ID
    militaryVerificationStatus: MilitaryVerificationStatusType
    errorType: MilitaryVerificationErrorType
    errorMessage: String
}

input UpdateMilitaryVerificationInput {
    id: ID!
    militaryVerificationStatus: MilitaryVerificationStatusType!
    updatedAt: AWSDateTime
}

input GetMilitaryVerificationInput {
    id: ID!
}

input CreateMilitaryVerificationInput {
    id: ID!
    firstName: String!
    lastName: String!
    dateOfBirth: String!
    enlistmentYear: String!
    addressLine: String!
    city: String!
    state: String!
    zipCode: String!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
    militaryDutyStatus: MilitaryDutyStatus!
    militaryBranch: MilitaryBranch!
    militaryAffiliation: MilitaryAffiliation!
}
# graphql/CardLinkingSchema.graphql
# Card Linking Schema File
enum CardLinkErrorType {
    ALREADY_EXISTENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    NONE_OR_ABSENT
    INVALID_CARD_SCHEME
}

enum CardType {
    MASTERCARD
    VISA
    INVALID
}

type Card @aws_cognito_user_pools {
    id: ID! # this will be obtained from Olive (and it is the Olive card id)
    applicationID: ID! # this will be passed on to Olive as the enrollment ID (referenceAppId)
    token: String!
    type: CardType!
    name: String!
    last4: String!
    additionalProgramID: String # not all card will have additional program IDs enrolled to them
}

type CardLink @aws_cognito_user_pools {
    id: ID! # this will be passed on to Olive as the unique user ID (extMemberId), and represents Moonbeam's unique user ID
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cards: [Card]!
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
}

type Member @aws_cognito_user_pools {
    id: ID!
    memberId: ID!
    isActive: Boolean
}

type CardUpdate @aws_cognito_user_pools {
    id: ID!
    cardId: ID!
    updatedAt: AWSDateTime!
}

input CardInput {
    applicationID: ID # not required since this will be generated on the back-end
    token: String!
    type: CardType!
    name: String!
    last4: String!
    additionalProgramID: String # not required since cards will mainly only be enrolled into the default program ID for Moonbeam through Olive
}

input CreateCardLinkInput {
    id: ID!
    card: CardInput!
    createdAt: AWSDateTime
    updatedAt: AWSDateTime
}

input AddCardInput {
    id: ID!
    memberId: ID!
    card: CardInput!
    updatedAt: AWSDateTime
}

input GetCardLinkInput {
    id: ID!
}

input DeleteCardInput {
    id: ID!
    memberId: ID!
    cardId: ID!
    updatedAt: AWSDateTime
}

type CardResponse @aws_cognito_user_pools {
    data: CardUpdate
    errorType: CardLinkErrorType
    errorMessage: String
}

type CardLinkResponse @aws_cognito_user_pools {
    data: CardLink
    errorType: CardLinkErrorType
    errorMessage: String
}

type MemberResponse @aws_cognito_user_pools {
    data: Member
    errorType: CardLinkErrorType
    errorMessage: String
}

type RemoveCardResponse @aws_cognito_user_pools {
    data: Boolean
    errorType: CardLinkErrorType
    errorMessage: String
}
# graphql/TransactionsSchema.graphql
# Transactions Schema File
enum TransactionsErrorType {
    DUPLICATE_OBJECT_FOUND
    NONE_OR_ABSENT
    VALIDATION_ERROR
    UNEXPECTED_ERROR
    UNPROCESSABLE
}

# Defines the types of the statuses for a transaction, during its lifecycle. Although these
# statuses might not match Olive's statuses 1:1, they represent what our customers see in their
# dashboard, and how we translate incoming Olive information, and communicate it to our end
# users.
enum TransactionsStatus {
    PENDING
    PROCESSED
    CREDITED
    REJECTED
}

# Defines the type of transactions that are available, depending on incoming information received
# through the Olive webhooks. The transactions processor, will handle these transaction types and
# determine whether they are offers to be redeemed, round-ups, contributions/matching, etc.
enum TransactionType {
    OFFER_REDEEMED
    ROUNDUP
    CONTRIBUTION
}

# For now we only support USD as the currency code type for transactions
enum CurrencyCodeType {
    USD
}

# this type is mainly used to define and/or work with the Transaction object before it is stored
# in the DB, as obtained from Olive.
type Transaction @aws_cognito_user_pools {
    id: ID # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float,
    totalAmount: Float,
    pendingCashbackAmount: Float # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String,
    transactionBrandDescription: String,
    transactionBrandAddress: String,
    transactionBrandLogoUrl: String
}

# this type is mainly used to define and/or work with the TransactionResponse object before it is stored
# in the DB, as obtained from Olive.
type TransactionResponse @aws_cognito_user_pools @aws_api_key {
    data: Transaction
    errorType: TransactionsErrorType
    errorMessage: String
}

type MemberDetailsResponse @aws_cognito_user_pools @aws_api_key {
    data: String
    errorType: TransactionsErrorType
    errorMessage: String
}

type MoonbeamTransaction @aws_cognito_user_pools @aws_api_key {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandDescription: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!
}

type MoonbeamTransactionResponse @aws_cognito_user_pools @aws_api_key {
    id: ID # this represents the userID of the transaction, and the reason we repeat it in the parent response is for the subscription filtering to work properly
    data: MoonbeamTransaction
    errorType: TransactionsErrorType
    errorMessage: String
}

input CreateTransactionInput {
    id: ID! # this represents the userID which the transaction belongs to/was made by
    timestamp: AWSTimestamp! # this represents the timestamp, in a Number epoch based format (for sorting purposes)
    transactionId: ID!
    transactionStatus: TransactionsStatus!
    transactionType: TransactionType!
    createdAt: AWSDateTime! # this will be the same as the "timestamp" value above, only represented in a date time format
    updatedAt: AWSDateTime!
    memberId: ID! # this will be obtained from Olive (and it is the Olive member id)
    cardId: ID!
    brandId: ID!
    storeId: ID!
    category: String!
    currencyCode: CurrencyCodeType!,
    rewardAmount: Float!,
    totalAmount: Float!,
    pendingCashbackAmount: Float! # this amount should be the total reward amount that's pending reimbursement to the customer
    creditedCashbackAmount: Float! # this amount should be the total reward amount that's reimbursed/credited to the customer
    transactionBrandName: String!,
    transactionBrandDescription: String!,
    transactionBrandAddress: String!,
    transactionBrandLogoUrl: String!
}
